var documenterSearchIndex = {"docs":
[{"location":"pages/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"pages/","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CamiDiff","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiDiff.jl is a Julia package for one-dimensional finite-difference analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is installed using the Julia package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"CamiDiff\")\n\njulia> using CamiDiff","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiDiff has been developped to study continuously differentiable functions, provided by the user in tabulated form.  The package is based on the methods of finite-difference analysis in one dimension. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Throughout the documentation f(x) will be our function of interest under investigation. The tabulated form can be regarded as  the result of discretization of f(x), onto a Grid of N points, addressable by the gridindex n = 1  N. The Grid can be linear or non-linear as specified by a gridfunction - see Discretization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current implementation of CamiDiff was developped for real functions of a single variable, using  gridfunctions restricted to the domain 0 ). A set of four predefined gridtypenames is included: 'exponential',  'quasi-exponential', 'linear' and 'polynomial'. To underline the restriction to the non-negative domain, we shall often  use the variable r rather than x, writing f(r) rather than f(x), with the implicit condition r  0.","category":"page"},{"location":"#Discretization","page":"Home","title":"Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mathematically, the discretization is based on the map n  x which defines the discrete function","category":"page"},{"location":"","page":"Home","title":"Home","text":"xn = s_0 * g(tn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here g(t) is called the gridfunction and s_0 the scaling factor. The gridfunction  is defined as a (generally nonlinear) function running through the origin: g(0) = 0. Its argument is  the ticks function","category":"page"},{"location":"","page":"Home","title":"Home","text":"tn  (nu) * h","category":"page"},{"location":"","page":"Home","title":"Home","text":"which is a discrete linear function, where u is called the index base and h the step size. Writing","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn = f(xn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"we recognize in fn a discrete function representing the function f(x) at position xn. This represents  the tabulated function that has to be provided by the user. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB. The discrete function fn is defined on the uniform grid of the natural numbers. This uniformity greatly  simplifies the numerical analysis. The stepsize h determines the coarseness of the grid. The results  of a finite-difference calculation on a coarse grid will be less accurate than those on a fine grid, but  the algorithm is identical, because the relevant finite-difference expansions only depend on h implicitely.  Since Julia uses unit-based indexing (u = 1), the index convention implies f1 = f(0).  ","category":"page"},{"location":"#Grid","page":"Home","title":"Grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Grid object is the backbone for numerical procedures. Its principal fields are grid.r, grid.r′  and grid.r′′. These are discrete functions of N elements representing the grid function and its first two derivatives.  The function fn is tabulated on this Grid and the function rn represents the transformation by the gridfunction. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the Grid is specified, three basic operations are at our disposal - see Manual","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_interpolation(f, rval, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_differentiation(f, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_integration(f, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid{T}\ncastGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, polynom=[0,1], epn=5, k=7, msg=true)\ngridfunction(ID::Int, n::Int, h::T; p=5, polynom=[0,1], deriv=0) where T <: Real\ngridtypename(ID::Int)\ngridtypeID(name::String)\ngridPos(rval::T, grid::Grid{T}) where T<:Real\nfracPos(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T<:Real","category":"page"},{"location":"#CamiDiff.Grid","page":"Home","title":"CamiDiff.Grid","text":"Grid(ID, name, T, N, r, r′, r′′, h, r0, epn, epw, k, p, polynom)\n\nType with fields:\n\n.ID:    grid identifer name (::Int)\n.name:  grid identifer name (::String)\n.T:     gridtypename (::Type)\n.N:     number of grid points (::Int)\n.r:   tabulated grid function (::Vector{T})\n.r′:   tabulated first derivative of grid function (::Vector{T})\n.r′′:   tabulated second derivative of grid function (::Vector{T})\n.h :    grid step multiplyer (::T)\n.r0:    grid scale factor (::T)\n.epn:   number of endpoints used for trapezoidal endpoint correction (must be odd) (::Int)\n.epw:   trapezoidal endpoint weights for n=1:epn (::Vector{Vector{T}})\n.k:     finite-difference order (::Int)\n.p:     only for quasi-exponential grid; truncation power (::Int)\n.polynom: only for polynomial grid: polynom (::Vector{T})\n\nThe object Grid is best created with the function castGrid.\n\n\n\n\n\n","category":"type"},{"location":"#CamiDiff.castGrid-Tuple{Int64, Int64, Type}","page":"Home","title":"CamiDiff.castGrid","text":"castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, polynom=[0,1], epn=5, k=7, msg=false)\ncastGrid(name::String, N::Int, T::Type; h=1, r0=1, p=5, polynom=[0,1], epn=5, k=7, msg=false)\n\nMethod to create the Grid object\n\nID = 1: exponential, ID = 2: quasi-exponential, ID = 3: linear (uniform) ID = 4: polynomial\n\nExamples:\n\njulia> grid = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid = castGrid(\"exponential\", 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);\nGrid: quasi-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1\n\njulia> grid = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);\nGrid: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1\n\njulia> grid = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);\nGrid: polynomial of degree 2, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001\n\njulia> grid.r[1:4]\n4-element Vector{Float64}:\n [2.220446049250313e-16, 1.0000000000000003e-5, 4.000000000000001e-5, 9.000000000000003e-5]\n\njulia> grid.r′[1:4]\n4-element Vector{Float64}:\n [0.0, 2.0000000000000005e-5, 4.000000000000001e-5, 6.0000000000000015e-5]\n \njulia> grid.r′′[1:4]\n4-element Vector{Float64}:\n [2.0000000000000005e-5, 2.0000000000000005e-5, 2.0000000000000005e-5, 2.0000000000000005e-5] \n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Home","title":"CamiDiff.gridfunction","text":"gridfunction(ID::Int, n::Int, h::T; p=5, polynom=[0,1], deriv=0) where T <: Real\n\nCamiDiff offers three internal gridfunctions:\n\nID = 1: exponential grid function,\n\n    g(t) = e^t - 1\n\nID = 2: quasi-exponential grid function of degree p (linear grid for p = 1),\n\n    g(t) = t + frac12t^2 +  + frac1pt^p\n\nID = 3: linear grid function,\n\n    g(t) = t\n\nID = 4: polynomial grid function of degree p = length(c)-1 defined by its CamiMath.polynom vector c = c_0 c_1c_2 c_p,\n\n    g(t) = c_0 + c_1 t + c_2 t^2 +  + c_p t^p\n\nwith c_0  0 because, by definition, all grid functions run through the origin, g(0) = 0. \n\nThe actual grid is given by \n\n    xn = r_0 * g(tn)\n\nwhere tn = (n-1) * h is the ticks function for the unit-based indexing of Julia.\n\nNB. Note that t1 = 0 and x1 = 0 for all grid functions.\n\nExamples:\n\njulia> h = 0.1; r0=1.0; N=4;\n\njulia> r = r0 .* [gridfunction(1, n-1, h) for n=1:N]\n[0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]\n\njulia> r′ = r0 .* [gridfunction(1, n-1, h; deriv=1) for n=1:N]\n[0.1, 0.11051709180756478, 0.122140275816017, 0.13498588075760032]\n\njulia> r′′= r0 .* [gridfunction(1, n-1, h; deriv=2) for n=1:N]\n[0.010000000000000002, 0.011051709180756479, 0.012214027581601701, 0.013498588075760034]\n\njulia> r = r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1]) for n=1:N]\n[0.0, 0.010000000000000002, 0.04000000000000001, 0.09000000000000002]\n\njulia> r′ = r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1], deriv=1) for n=1:N]\n[0.0, 0.020000000000000004, 0.04000000000000001, 0.06000000000000001]\n\njulia> r′′= r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1], deriv=2) for n=1:N]\n[0.020000000000000004, 0.020000000000000004, 0.020000000000000004, 0.020000000000000004]\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridtypename-Tuple{Int64}","page":"Home","title":"CamiDiff.gridtypename","text":"gridtypename(ID::Int)\n\nName corresponding to the Grid ID.\n\nExample:\n\njulia> gridtypename(2)\n\"quasi-exponential\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridtypeID-Tuple{String}","page":"Home","title":"CamiDiff.gridtypeID","text":"gridtypeID(name::String)\n\nID corresponding to the gridtypename.\n\nExample:\n\njulia> gridtypeID(\"quasi-exponential\")\n2\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridPos-Union{Tuple{T}, Tuple{T, Grid{T}}} where T<:Real","page":"Home","title":"CamiDiff.gridPos","text":"gridPos(rval::T, grid::Grid{T}) where T<:Number\n\nThe approximate grid position defined as the largest integer n satisfying the  condition grid.r[n] < rval on the Grid.\n\nExample:\n\njulia> h = 0.1; r0 = 1.0;\n\njulia> grid = castGrid(1, 4, Float64; h, r0);\n\njulia> r = grid.r; println(\"r[3] = $(r[3])\")\nr[3] = 0.22140275816016985\n\njulia> gridPos(0.222, grid)\n3\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.fracPos-Union{Tuple{T}, Tuple{Int64, T, Grid{T}}} where T<:Real","page":"Home","title":"CamiDiff.fracPos","text":"fracPos(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T<:Real\n\nFractional grid offset with respect to Grid position n.\n\n\n\n\n\n","category":"method"},{"location":"#Finite-differences","page":"Home","title":"Finite differences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Having discretized the analytic function f(x), one defines finite differences.  The forward difference of f(x+h) and f(x) is defined by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Δ f(x)=f(x+h)-f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, Δ is called the forward-difference operator. Likewise one defines backward differences  with the backward-difference operator , ","category":"page"},{"location":"","page":"Home","title":"Home","text":" f(x)=f(x)-f(x-h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We first focus on forward differences. The derivative of f(x) is given by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f^(x)=underseth0mathrmlimfracf(x+h)-f(x)h=undersetΔ x0mathrmlimfracΔ f(x)Δ x","category":"page"},{"location":"","page":"Home","title":"Home","text":"where h  Δx  0 is the difference interval. Introducing the differential operator, f^(x)  Df(x), we have ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dfracddx=undersetΔ x0mathrmlimfracΔΔ x=underseth0mathrmlimfracΔh","category":"page"},{"location":"#Translation-operators","page":"Home","title":"Translation operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"With regard to forward differences we rewrite the forward difference definition in the form of a forward translation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x+h)=(1+Δ)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where T(1+Δ) is the forward translation operator. This operator shifts the function over the infinitesimal interval h to larger values of x. The translation operator can be expressed in terms of the differential operator as follows by Taylor expansion of f(x) about the point x, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x h)=(1 hD+tfrac12h^2D^2tfrac13h^3D^3+)f(x)=e^ hDf(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comparing the operator expression for the forward translation with the Taylor expansion we obtain, by formal inversion of the operator T, an operator identity for the inverted translation operator T^-1,    ","category":"page"},{"location":"","page":"Home","title":"Home","text":"T(1+Δ)=e^hDT^-1=e^-hD=(1+Δ)^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this procedure, the explicit dependence on h can be replaced by an implicit dependence on h through an expansion in powers of Δ ,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x-h)=(1+Δ)^-1f(x)=(1-Δ+Δ^2-Δ^3+)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By choosing the proper expansion order, f(x-h) can be approximated to any desired level of accuracy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Likewise, for backward differences, we rewrite the backward-difference definition in the form ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x-h)=(1-)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(1-) is the backward translation operator. Comparing this backward translation with the Taylor expansion we obtain, by formal inversion of the operator B, an operator identity for the forward translation operator T, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"B(1-)=e^-hD=T^-1T=e^hD=(1+)^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note how the backward translation operator was identified with the inverse forward translation operator, B=T^-1. When using backward differences, the explicit dependence on h can be replaced by an implicit dependence on h through an expansion in powers of , ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x+h)=(1-)^-1f(x)=(1++^2+^3+)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By choosing the proper expansion order, f(x+h) can be approximated to any desired level of accuracy. ","category":"page"},{"location":"pages/manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"pages/manual/#Finite-differences","page":"Manual","title":"Finite differences","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Consider the analytical function f tabulated in forward order   (growing index) at n positions on a uniform grid.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Forward difference notation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The forward translation from position n-1 to position n on  the grid is expressed by the relation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn = (1 + Δ) fn-1 ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where Δ is the forward difference operator. By formal inversion   we find","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where Δ^k is the  k^th-order forward difference defined as a weighted sum over the function values fnn+k (involving k+1 points appearing in regular=forward order),","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"beginaligned\nΔ^k fn = fn+k + c_1^kfn+k-1 +   + fn \n         = fn + c_k-1^kfn+1 +   + fn+k = sum_j=0^k c_k-j^k fn+j\nendaligned","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the k+1 coefficients c_k-j^k=(-1)^k c_j^k,  with","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"c_j^k=(-1)^jbinomkj","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"are the summation weights (short: weights) defining the summation, with special values  c_0^k1 and c_k^k(-1)^k.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"In inner product form the result becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Δ^k fn=barc^k cdot fnn+k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where barc^k   c_k^k c_0^k.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Backward difference notation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The backward translation from position n to position n-1 on  the grid is expressed by the relation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn = (1 - ) fn+1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where  is the backward difference operator.  By formal inversion   we obtain in this case","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn+1=(1-)^-1fn=(1++^2+^3+)fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where ^k is the  k^th-order backward difference defined as a weighted sum over the function values fn-1n-k (involving  k+1 points appearing in reversed order),","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"^k fn = fn + c_1^kfn-1 +  + fn-k\n= sum_j=0^k c_j^kfn-j","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the k+1 coefficients c_j^k are the summation weights  (short: weights) defining the summation. ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"In inner product form the result becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"^k fn = c^k cdot fn-1n-k =barc^k cdot fn-kn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where c^k   c_0^k c_k^k.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Coefficients:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_weight(k, j)  c^k  c_0^k c_k^k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"# isforward(notation)\n# isregular(ordering)\nfdiff_weight(k::Int, j::Int)","category":"page"},{"location":"pages/manual/#CamiDiff.fdiff_weight-Tuple{Int64, Int64}","page":"Manual","title":"CamiDiff.fdiff_weight","text":"fdiff_weight(k::Int, j::Int)\n\nFinite difference weight coefficient,\n\nc_j^k=(-1)^jbinomkj\n\nExample:\n\njulia> c(k,j) = fdiff_weight(k,j);\n\njulia> a = [[c(k,j) for j=0:k] for k=0:3]\n4-element Vector{Vector{Int64}}:\n [1]\n [1, -1]\n [1, -2, 1]\n [1, -3, 3, -1]\n\njulia> b = [[c(k,k-j) for j=0:k] for k=0:3]\n4-element Vector{Vector{Int64}}:\n [1]\n [-1, 1]\n [1, -2, 1]\n [-1, 3, -3, 1]\n\njulia> b == reverse.(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#Finite-difference-expansions","page":"Manual","title":"Finite difference expansions","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Finite-difference calculus builds on finite-difference expansions on a uniform grid.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Forward difference notation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"In terms of forward differences the generic form of the finite-difference expansion is given by","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^inftyα_pΔ^pfn\n=sum_p=0^kα_pΔ^pfn+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Evaluated to order k, the expansion is defined by k+1 finite-difference expansion coefficients,  supplied by the user in the form of the expansion vector, α = α_0 α_k. This vector contains the coefficients in the regular ordering of growing index. It takes some bookkeeping to rewrite the expansion  as a weighted sum over the k+1 function values fnn+k (note the regular ordering of growing grid position). Substituting the definition of the forward difference, Δ = fn+1 - fn,  the finite-difference expression takes the form","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^kα_pΔ^pfn\n=sum_p=0^kα_psum_j=0^pc_p-j^pfn+j\n=sum_j=0^ksum_p=j^kα_pc_p-j^pfn+j\n=sum_j=0^kF_j^kfn+j","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the weighted summation is defined by the weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"F_j^k=sum_p=j^kα_pc_p-j^p\n=sum_p=j^k(-1)^p+jbinompjα_p","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"with j=0 k. In inner product form, the expansion becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where F^k   F_0^k F_k^k.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Coefficients:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(polynom, fwd, reg)  F^k  F_0^k F_k^k,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where polynom is the expansion vector α  α_0 α_k, which has to be supplied by the user  to define the expansion under consideration.  ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Some common cases are:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"interpolation expansion: fdiff_interpolation_expansion_polynom(ξ, k, fwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"differentiation expansion: fdiff_differentiation_expansion_polynom(ξ, k, fwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Adams-Bashford expansion: fdiff_adams_bashford_expansion_polynom(k, fwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Adams-Moulton expansion: fdiff_adams_moulton_expansion_polynom(k, fwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Backward difference notation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"In terms of backward differences the generic form of the finite-difference expansion is given by","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^inftyβ_p^pfn=sum_p=0^kβ_p^pfn+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"In this case the k^th- order finite-difference expansion is defined by the (user-supplied) expansion vector β = β_0 β_k, containing the expansion coefficients  in regular ordering (growing index). The expansion can written as  a weighted sum over the k+1 function values fn-1n-k (note reversed ordering  of decreasing grid position). Substituting the definition of the backward difference,  = fn - fn-1,  the finite-difference expression takes the form","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^kβ_p^pfn\n=sum_p=0^kβ_psum_j=0^pc_j^pfn-j\n=sum_j=0^ksum_p=j^kβ_pc_j^pfn-j\n=sum_j=0^kB_j^kfn-j","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the weights are given by","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"B_j^k=sum_p=j^kβ_pc_j^p\n=sum_p=j^k(-1)^jbinompjβ_p","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"with j=0 k. In inner product form, the expansion becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^kβ_p^pfn\n=sum_j=0^k B_j^k fn-j\n=barB^k cdot fn-kn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where barB^k  B_k^k B_0^k is the weights vector B^k  B_0^k B_k^k tabulated  in reversed order.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The relation between B^k and F^k depends on the relation between the expansion polynoms α and β, which is not unique (it depends on the expansion under consideration).","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Coefficients:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(polynom, bwd, rev)  barB^k  B_k^k B_0^k,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where polynom is the expansion vector β  β_0 β_k, which has to be supplied by the user  to define the expansion under consideration. ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Some common cases are:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"interpolation expansion: fdiff_interpolation_expansion_polynom(ξ, k, bwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"differentiation expansion: fdiff_differentiation_expansion_polynom(ξ, k, bwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Adams-Bashford expansion: fdiff_adams_bashford_expansion_polynom(k, bwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Adams-Moulton expansion: fdiff_adams_moulton_expansion_polynom(k, bwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion(polynom, f, notation=CamiMath.bwd)\nfdiff_expansion_weights(polynom, notation=CamiMath.bwd, ordering=CamiMath.rev)","category":"page"},{"location":"pages/manual/#CamiDiff.fdiff_expansion","page":"Manual","title":"CamiDiff.fdiff_expansion","text":"fdiff_expansion(polynom, f [, notation=bwd])\n\nFinite difference expansion evaluated to k^th order for the analytical  function f, tabulated in regular order (growing index) at k+1 positions  on a Grid. The expansion coefficients are specified by the vector  polynom. By default the expansion is calculated in backward-difference notation (bwd). \n\nForward difference notation (notation = fwd)\n\nsum_p=0^kα_pΔ^pfn = F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytical function f (tabulated in  forward order) and polynom is the (user-supplied) expansion coefficient vector  α  α_0 α_k.\n\nBackward difference notation (notation = bwd)\n\nsum_p=0^kβ_p^pfn = barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytical function f (tabulated in forward order) and polynom is the (user-supplied) expansion coefficient vector β  β_0 β_k.\n\nNB. The vector polynom determines the order of the expansion,  k+1 = rmlength(α) = rmlength(β). The weights vectors F^k and  barB^k are internally generated by the function fdiff_expansion_weights(polynom, notation, ordering).\n\nExamples:\n\nConsider the function f(x)=x^2 and the expansions,\n\nbeginaligned\nfn-1=(1+Δ)^-1=(1-Δ+Δ^2-Δ^3+)fn=F^k cdot fnn+k\nfn=(1+Δ)^-1=(1-Δ+Δ^2-Δ^3+)fn+1=F^k cdot fn+1n+k+1\nendaligned\n\nbeginaligned\nfn+1=(1-)^-1=(1++^2+^3+)fn=barB^k cdot fn-kn\nfn=(1-)^-1=(1++^2+^3+)fn-1=barB^k cdot fn-k-1n-1\nendaligned\n\nNote that, in these examples, to fourth order in the expansion (k=4),  the forward- and backward-difference coefficient vectors polynom are  given by α=1-11-11 and β=11111, respectively. \n\njulia> f = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100];\n\njulia> α = [1,-1,1,-1,1];\n\njulia> β = [1,1,1,1,1];\n\njulia> fdiff_expansion(α,f[7:11],fwd)\n25\n\njulia> fdiff_expansion(β,f[1:5],fwd)\n25\n\njulia> f[6]\n25\n\nIn these cases the results are exact because the function is quadratic and the expansion is third order (based on the polynomial of k^th degree running through the k+1 points of the tabulated function). Compare with  the example of fdiff_interpolation(f, v, k=3).\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/#CamiDiff.fdiff_expansion_weights","page":"Manual","title":"CamiDiff.fdiff_expansion_weights","text":"fdiff_expansion_weights(polynom [, notation=bwd [, ordering=rev]])\n\nWeights vector corresponding to the expansion coefficient vector polynom of a (user-defined) finite-difference expansion.\n\nForward-difference notation (notation = fwd)\n\nThe weights vector F^k  F_k^k F_0^k corresponds in this case to the expansion coefficient  vector α  α_0 α_k of the k^th-order forward-difference expansion (polynom = α).\n\nsum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytic function f tabulated in regular=forward order.\n\nfdiff_expansion_weights(α, fwd, reg)  F^k  F_0^k F_k^k,\n\nwhere α  α_0 α_k has to be supplied by the user in combination with fwd to indicate that the weights must be evaluated in forward-difference notation.\n\nBackward difference notation (notation = bwd)\n\nThe weights vector barB^k  B_k^k B_0^k corresponds in this case to the expansion c oefficient vector β  β_0 β_k of the k^th-order backward-difference expansion (polynom = β).\n\nsum_p=0^kβ_p^pfn\n=sum_j=0^kB_j^kfn-j\n=barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytic function f tabulated in forward order.\n\nfdiff_expansion_weights(β, bwd, rev)  barB^k  B_k^k B_0^k,\n\nwhere β  β_0 β_k has to be supplied by the user in combination with bwd to indicate that the weights must be evaluated in backward-difference notation.\n\nExample:\n\nConsider the expansions,\n\nbeginaligned\nfn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn=F^k cdot fnn+k\nfn+1=(1-)^-1fn=(1++^2+^3+)fn=barB^k cdot fn-kn\nendaligned\n\njulia> f = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100];\n\njulia> α = [1,-1,1,-1,1];\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [5, -10, 10, -5, 1]\n\njulia> β = [1,1,1,1,1];\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = [1, -5, 10, -10, 5]\n\njulia> sum(Fk .* f[7:11]) # inner product\n25\n\njulia> sum(revBk .* f[1:5]) # inner product\n25\n\njulia> f[6]\n25\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/#Lagrange-interpolation","page":"Manual","title":"Lagrange interpolation","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The Lagrange polynomial of degree k on a uniform grid is the polynomial running  through k+1 subsequent points on the grid. We derive expressions for  interpolation in both forward- and backward-difference notation. Beware  that Lagrange interpolation becomes inaccurate if the tabulated function cannot be  approximated by a polynomial of degree k.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Forward difference notation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Starting from the forward translation expression","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn=(1+Δ)fn-1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"we obtain by formal operator inversion","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn-1 = (1 + Δ)^-1 fn  sum_p=0^infty(-1)^p Δ^p fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn-2 = (1 + Δ)^-2 fn  sum_p=0^infty(-1)^p pΔ^p fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"vdots","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where p is called the order of the expansion and n is the index of the reference position. For interpolation position n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn-σ = (1 + Δ)^-σ fn  sum_p=0^infty (-1)^p l_p(σ) Δ^p fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where α_p(σ) = (-1)^p l_p(σ) is the p^th-order finite-difference expansion coefficient for lagrangian interpolation. Here we define ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"l_p(σ)  (σ)_pp","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"with","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"(σ)_p=begincases\n1  p=0\nσ(σ+1)(σ+2)cdots(σ+p-1)  p0\nendcases","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"being the Pochhammer symbol CamiMath.pochhammer. Note that for σ = 1 we find  α_p  α_p(1)  (-1)^p, regaining the expansion coefficients obtained above in the  example of CamiDiff.fdiff_expansion. ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"For -k  σ  0 the method can be used for interpolation over the grid position interval  n  x  n+k. Outside this interval, in particular for σ  0, the method amounts to  extrapolation. The method is most accurate for -1  σ  1 (corresponding to the grid  position interval n-1  x  n+1). Extrapolation to values x  n+k is not recommended. ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Evaluating the finite-difference expansion up to order k we obtain  ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn-σ =sum_p=0^kα_p(σ)Δ^pfn\n=sum_j=0^kF_j^k(σ)fn+j\n=F^k(σ) cdot fnn+k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the k+1 weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"F_j^k(σ)= sum_p=j^k (-1)^k α_p(σ) c_j^p\n=sum_p=j^k (-1)^j binompj(σ)_pp","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"are the lagrangian interpolation weights corresponding to the point fn-σ.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Symmetry relation:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"barF^k(-k-σ) = F^k(σ)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Weight functions:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(polynom, fwd, reg)  F^k(σ)  F^k_0(σ) F^k_k,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the vector","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"polynom =fdiff_interpolation_expansion_polynom(σ, k, fwd)  α(σ)  α_0(σ) α_k(σ)  contains the coefficients of the lagrangian-interpolation expansion.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Backward difference notation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Starting from the relation","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn=(1-)fn+1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"we obtain by formal operator inversion","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn+1 = (1 - )^-1 fn  sum_p=0^infty^p fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn+2 = (1 - )^-2 fn  sum_p=0^inftyp^p fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"vdots","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where k is called the order of the expansion and n is the reference index. For interpolation position n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn+σ = (1 - )^-σ fn  sum_p=0^infty l_p(σ) ^p fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where β_p(σ) = l_p(σ) is the p^th-order finite-difference expansion coefficient  for lagrangian interpolation, with (σ)_p being the Pochhammer symbol CamiMath.pochhammer.   Note that for σ = 1 we find β_p  β_p(1)  1, regaining the expansion coefficients obtained above in the  example of CamiDiff.fdiff_expansion. ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"For -k  σ  0 the method can be used for interpolation over the grid position interval  n-k  x  n, outside this interval, in particular for σ  0, the method amounts to  extrapolation. The method is most accurate for -1  σ  1 (corresponding to the grid  position interval n-1  x  n+1). Extrapolation to values x  n-k is not recommended. ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Evaluating the finite-difference expansion up to order k we obtain","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn+σ =sum_p=0^kβ_p(σ)^pfn\n= sum_j=0^kB^k_j(σ)fn-j\n= barB^k(σ)  fn-kn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the k+1 weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"B^k_j(σ)= sum_p=j^k β_p(σ) c_j^p","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"are the corresponding lagrangian interpolation weights.  ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Symmetry relations:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"B^k(σ) = F^k(σ) = barB^k(-k-σ)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"barB^k(σ) = B^k(-k-σ)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Weight function:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(polynom, bwd, rev)  barB^k(σ)  B_k^k(σ) B_0^k(σ),","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the vector","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"polynom =fdiff_interpolation_expansion_polynom(σ, k=3, notation=bwd)  β(σ)  β_0(σ) β_k(σ) contains the coefficients of the lagrangian-interpolation expansion.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_interpolation_expansion_polynom(σ::T, notation=bwd; k=3) where T<:Real\nfdiff_interpolation_expansion_weights(σ::T, notation=bwd, ordering=rev; k=3) where T<:Real\nfdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}","category":"page"},{"location":"pages/manual/#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T<:Real","page":"Manual","title":"CamiDiff.fdiff_interpolation_expansion_polynom","text":"fdiff_interpolation_expansion_polynom(σ::T [, notation=bwd [; k=3]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining the k^th-order (default third order) Lagrange-polynomial interpolation of a tabulated analytic function fn at offset σ with respect to index position n, which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nIn this case we consider the tabulated interval fnn+k. The interpolated value fn-σ is given by the forward-difference expansion\n\nfn-σ = sum_p=0^k α_p(σ) Δ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(σ, fwd; k=3)  α(σ)  α_0(σ) α_k(σ). \n\nApplication: This polynom can serve to predict f[n-1] by extrapolation (using σ=1)  if f[n:n+k] are known. More generally, it can serve to interpolate to (real) positions  n  x  n+k (using -k  σ  0) and predict f[n-σ] by extrapolation to (real)  positions xn (using σ  0) or xn+k (using σ  -k).  NB. The forward offset  is given by σ  n-x.\n\nBackward difference notation (notation = bwd)\n\nIn this case we consider the tabulated interval fn-kn. The interpolated value fn+σ is given by the backward-difference expansion\n\nfn+σ = sum_p=0^k β_p(σ) ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(σ, bwd; k=3)  β(σ)  β_0(σ) β_k(σ). \n\nApplication: This polynom can serve to predict f[n+1] by extrapolation (using σ=1)  if f[n-k:n] are known. More generally, it can serve to interpolate to (real) positions  n-k  x  n (using -k  σ  0) and predict f[n+σ] by extrapolation to (real)  positions xvn (using σ  0) or xn+k (using σ  -k). NB. The backward offset  is given by σ  -(n-x).\n\nExample 1 - extrapolation on a uniform grid\n\njulia> σ = 1; # offset\n\njulia> f = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];\n\njulia> α = fdiff_interpolation_expansion_polynom(σ, fwd; k=5); println(\"α = $α\")\nα = [1, -1, 1, -1, 1, -1]\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [6, -15, 20, -15, 6, -1]\n\njulia> Fk ⋅ f[5:10] == f[4] == 16\ntrue\n\njulia> β = fdiff_interpolation_expansion_polynom(σ, bwd; k=5); println(\"β = $β\")\nβ = [1, 1, 1, 1, 1, 1]\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = [-1, 6, -15, 20, -15, 6]\n\njulia> revBk ⋅ f[1:6] == f[7] == 49\ntrue\n\n\nExample 2 - forward-difference interpolation on a uniform grid\n\njulia> f = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\njulia> x = 7.25; n = 5; k = 5;\n\njulia> σ = n-x # offset (case: forward-difference interpolation)\n-2.25\n\njulia> α = fdiff_interpolation_expansion_polynom(σ, fwd; k); println(\"α = $α\")\nα = [1.0, 2.25, 1.40625, 0.1171875, -0.02197265625, 0.0076904296875]\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [0.0093994140625, -0.0845947265625, 0.845947265625, 0.281982421875, -0.0604248046875, 0.0076904296875]\n\njulia> Fk ⋅ f[n:n+k] ≈ x == 7.25\ntrue\n\nExample 3 - backward-difference interpolation on a uniform grid\n\njulia> f = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\njulia> x = 7.25; n = 9; k = 5;\n\njulia> σ = -(n-x) # offset (case: backward-difference interpolation)\n-1.75\n\njulia> β = fdiff_interpolation_expansion_polynom(σ, bwd; k); println(\"β = $β\")\nβ = [1.0, -1.75, 0.65625, 0.0546875, 0.01708984375, 0.0076904296875]\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = [-0.0076904296875, 0.0555419921875, -0.199951171875, 0.999755859375, 0.1666259765625, -0.0142822265625]\n\njulia> revBk ⋅ f[n-k:n] ≈ x == 7.25\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.fdiff_interpolation_expansion_weights-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Manual","title":"CamiDiff.fdiff_interpolation_expansion_weights","text":"fdiff_interpolation_expansion_weights(σ::T, [, notation=bwd [, ordering=rev [, k=3]]]) where T<:Real\nfdiff_interpolation_expansion_weights(polynom [, notation=bwd [, ordering=rev]])\n\nFinite-difference expansion weights vector defining the k^th-order (default third order) Lagrange-polynomial interpolation of a tabulated analytic function fn at offset σ with respect to index position n, which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nIn this case we consider the tabulated interval fnn+k. The interpolated value fn-σ is given by the forward-difference expansion\n\nfn-σ = sum_p=0^k α_p(σ) Δ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(σ, fwd; k=3)  α(σ)  α_0(σ) α_k(σ). In this notation the range -k  σ  1 corresponds to interpolation and the ranges σ  -k and σ  1k to extrapolation.\n\nBackward difference notation (notation = bwd)\n\nIn this case we consider the tabulated interval fn-kn. The interpolated value fn+σ is given by the backward-difference expansion\n\nfn+σ = sum_p=0^k β_p(σ) ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(σ, bwd; k=3)  β(σ)  β_0(σ) β_k(σ). In this notation the range -k  σ  1 corresponds to interpolation and the ranges σ  -k and σ  1k to extrapolation.\n\nExamples:\n\njulia> Fk1 = fdiff_interpolation_expansion_weights(1, fwd, reg; k=4); println(\"Fk1 = $(Fk1)\")\nFk1 = [5, -10, 10, -5, 1]\n\njulia> revBk1 = fdiff_interpolation_expansion_weights(1, bwd, rev; k=4); println(\"revBk1 = $(revBk1)\")\nrevBk1 = [1, -5, 10, -10, 5]\n\njulia> α = fdiff_interpolation_expansion_polynom(1, fwd; k=4); println(\"α = $α\")\nα = [1, -1, 1, -1, 1]\n\njulia> Fk1 = fdiff_interpolation_expansion_weights(α, fwd, reg); println(\"Fk1 = $(Fk1)\")\nFk1 = [5, -10, 10, -5, 1]\n\njulia> β = fdiff_interpolation_expansion_polynom(1, bwd; k=4); println(\"β = $β\")\nβ = [1, 1, 1, 1, 1]\n\njulia> revBk1 = fdiff_interpolation_expansion_weights(β, bwd, rev); println(\"revBk1 = $(revBk1)\")\nrevBk1 = [1, -5, 10, -10, 5]\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T<:Real, V<:Real}","page":"Manual","title":"CamiDiff.fdiff_interpolation","text":"fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}\n\nFinite difference lagrangian interpolation (by default third order) at real position v (in index units) with respect to the elements of the uniformly tabulated analytic function f[1:N]. The interpolation points are situated on a Lagrange polynomial of degree k (by default third degree) running through k+1 subsequenct points of the tabulated function. Outside the tabulated range, the method represents extrapolation on the lagrangian polynomial defined by the first/last k+1 tabulated points.\n\nBeware that the interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.\n\nExamples:\n\nf = [1,2,3,4,5,6,7]\n[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]\n  [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]\n\nf = [1,4,9,16,25,36,49]\n[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]\n [1.0, 2.25, 4.0, 6.25, 9.0, 12.25, 16.0, 20.25, 25.0, 30.25, 36.0, 42.25, 49.0]\n\n f = [x^3 for x=-4:2]\n f1(v) = fdiff_interpolation(f, v; k=1)\n f2(v) = fdiff_interpolation(f, v; k=2)\n f3(v) = fdiff_interpolation(f, v; k=3)\n [[f1(v),f2(v),f3(v)] for v=1:0.5:9]\n   [[-64.0, -64.0, -64.0], [-45.5, -43.25, -42.875], [-27.0, -27.0, -27.0],\n   [-17.5, -16.0, -15.625], [-8.0, -8.0, -8.0], [-4.5, -3.75, -3.375],\n   [-1.0, -1.0, -1.0], [-0.5, -0.5, -0.125], [0.0, 0.0, 0.0],\n   [0.5, -0.25, 0.125], [1.0, 1.0, 1.0], [4.5, 3.75, 3.375], [8.0, 8.0, 8.0],\n   [11.5, 13.75, 15.625], [15.0, 21.0, 27.0], [18.5, 29.75, 42.875],\n   [22.0, 40.0, 64.0]]\n\nThe result for f3(v) is exact because the function is cubic and the expansion is third order - see Figure below. The tabulated function is given by the black points. The interpolation and extrapolation points are red.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#Lagrangian-differentiation","page":"Manual","title":"Lagrangian differentiation","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Forward difference notation (notation = fwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"To derive the lagrangian differentiation formulas we formally differentiate","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn-x = (1+Δ)^-x fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"with respect to -x,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"-fracdfdxn-x\n=ln(1+Δ) (1+Δ)^-xfn\n=sum_q=1^ktfrac1qΔ^qsum_p=0^k(-1)^pl_p(x)Δ^pfn+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Rewriting the r.h.s. as a single expansion in powers of , we obtain","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x=sum_p=1^kβ_p(x)Δ^pfn+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where β_p(x) represents the finite-difference expansion coefficients for lagrangian differentiation at position n+x. The coefficients β_p(x)  are obtained by polynomial multiplication using the function CamiMath.polynom_product(p1,p2),  where p_1 and p_2 are CamiMath.polynom vectors.  The resulting coefficients are contained in the following CamiMath.polynom vector of order k, ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_differentiation_expansion_polynom(k,x)  β(x)  β_0(x) β_p(x), with β_0(x) 0.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Substituting the finite-difference operators, the lagrangian derivative takes the form  ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x\n=sum_j=0^kB_j^k(x)fn-j\n=B^k(x)  fn-1n-k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the k+1 weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":" B_j^k(x)=sum_p=j^kβ_p(x)c_j^p","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"are the k^th-order lagrangian-differentiation weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(β, bwd, reg)  B^k(x)  B^k_0(x) B^k_k(x).","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"After changing dummy index to reverse the summation the expansion becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x\n=sum_j=0^kbarB^k_j(x)fn-k+j\n=barB^k(x)  fn-kn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(β, bwd, rev)  barB^k(x)  B^k_k(x) B^k_0(x).","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"backward difference notation (notation = bwd)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"To derive the lagrangian differentiation formulas we formally differentiate","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fn+x = (1 - )^-x fn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"with respect to x,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x\n=-ln(1-) (1-)^-xfn\n=sum_q=1^ktfrac1q^qsum_p=0^kl_p(x)^pfn+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Rewriting the r.h.s. as a single expansion in powers of , we obtain","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x=sum_p=1^kβ_p(x)^pfn+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where β_p(x) represents the finite-difference expansion coefficients for lagrangian differentiation at position n+x. The coefficients β_p(x)  are obtained by polynomial multiplication using the function CamiMath.polynom_product(p1,p2),  where p_1 and p_2 are CamiMath.polynom vectors.  The resulting coefficients are contained in the following CamiMath.polynom vector of order k, ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_differentiation_expansion_polynom(k,x)  β(x)  β_0(x) β_p(x), with β_0(x) 0.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Substituting the finite-difference operators, the lagrangian derivative takes the form  ","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x\n=sum_j=0^kB_j^k(x)fn-j\n=B^k(x)  fn-1n-k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the k+1 weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":" B_j^k(x)=sum_p=j^kβ_p(x)c_j^p","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"are the k^th-order lagrangian-differentiation weights","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(β, bwd, reg)  B^k(x)  B^k_0(x) B^k_k(x).","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"After changing dummy index to reverse the summation the expansion becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fracdfdxn+x\n=sum_j=0^kbarB^k_j(x)fn-k+j\n=barB^k(x)  fn-kn","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_expansion_weights(β, bwd, rev)  barB^k(x)  B^k_k(x) B^k_0(x).","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_differentiation_expansion_polynom(ξ::T, k=3) where T<:Real\ncreate_lagrange_differentiation_matrix(k::Int)","category":"page"},{"location":"pages/manual/#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T<:Real","page":"Manual","title":"CamiDiff.fdiff_differentiation_expansion_polynom","text":"fdiff_differentiation_expansion_polynom(ξ::T [, k=3 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining k^th-order lagrangian differentiation of the tabulated analytic function fn at offset ξ (with respect to index position n), which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nfracdfdξn+ξ=sum_p=0^kα_p(ξ)Δ^pfn\n\nOffset convention: ξ = -σ with respect to index n in tabulated interval fnn+k\n\nBackward difference notation (notation = bwd)\n\nfracdfdξn+ξ=sum_p=0^kβ_p(ξ)^pfn\n\nwhere β(ξ)  β_0(ξ)  β_p(ξ)\n\nOffset convention: ξ = σ with respect to index n in tabulated interval fn-kn\n\nExample:\n\nk = 2; ξ = 0\no = fdiff_differentiation_expansion_polynom(ξ, k); println(o)\n [0.0, 1.0, -1.5]\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}","page":"Manual","title":"CamiDiff.create_lagrange_differentiation_matrix","text":"create_lagrange_differentiation_matrix(k::Int)\n\nLagrange differentiation matrix, mij=s_k-j^k(i), for k^th-order lagrangian differentiation,\n\nfracdydxi= sum_j=0^kmijyj\n\nExample:\n\nk = 3\ncreate_lagrange_differentiation_matrix(k)\n 4×4 Matrix{Rational{Int64}}:\n  -11//6   3//1  -3//2   1//3\n   -1//3  -1//2   1//1  -1//6\n    1//6  -1//1   1//2   1//3\n   -1//3   3//2  -3//1  11//6\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#Integration","page":"Manual","title":"Integration","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"trapezoidal_epw(k::Int; rationalize=false, devisor=false)\ntrapezoidal_integration(f, x1, x2, weights)","category":"page"},{"location":"pages/manual/#CamiDiff.trapezoidal_epw-Tuple{Int64}","page":"Manual","title":"CamiDiff.trapezoidal_epw","text":"trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])\n\nEndpoint weights vector a=a_1 a_k of trapeziodal rule optimized for functions of polynomial form,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nwhere k is odd. The rule is exact for polynonials of degree d=0 1  k-1. For k=1 the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\n[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]\n5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n  (1, 2, [1])\n  (3, 24, [9, 28, 23])\n  (5, 1440, [475, 1902, 1104, 1586, 1413])\n  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])\n  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,\n                                                     5095890, 7783754, 7200319])\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.trapezoidal_integration-NTuple{4, Any}","page":"Manual","title":"CamiDiff.trapezoidal_integration","text":"trapezoidal_integration(f, x1, x2, weights)\n\nIntegral of the tabulated function f=f_0 f_n over the domain x1  x  x2 using the optimized trapezoidal rule with endpoint correction by the weights vector weights,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nThe rule is exact for polynonials of degree d=0 1 k-1. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples::\n\np = 3\nc = [1 for i=0:p]\npol = ImmutablePolynomial(c,:z)\nIpol = integrate(pol)\nn = 10\n\nx1=0.0\nx2=5.0\nx = collect(range(x1, x2, n))\nf = pol.(x .-2.5)\n\nw3 = trapezoidal_epw(3)\ntrapezoidal_integration(f, x1, x2, w3)\n 15.416666666666673\n\nIpol(2.5)-Ipol(-2.5)\n 15.41666666666666\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#Adams-Method","page":"Manual","title":"Adams Method","text":"","category":"section"},{"location":"pages/manual/#Adams-Bashford-expansion","page":"Manual","title":"Adams-Bashford expansion","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The Adams-Bashford integration step is given by the expansion","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"yn+1-yn = -frach (1-)ln(1-)fn+1=h (sum_p=0^inftyB_p^p)fn+1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"A closed expression for the Adams-Bashford expansion coefficients, B_k, is not available. As we already have a finite-difference expansion for the operator (1-)^-1,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"frac11-sum_p=0^infty^p","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"we ask for the expansion of","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"-fracln(1-)\n=(1-frac12-frac124^2-frac112^3+)fn+1\n= (sum_p=0^inftyb_p^p)fn+1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"This is known as the Adams-Moulton expansion. Its expansion coefficients are calculated numerically by the function fdiff_adams_moulton_expansion_polynom(k). The Adams-Bashford expansion is obtained as the polynomial product of the two expansions,","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"(sum_p=0^inftyB_p^p)fn+1\n=(sum_p=0^infty^p)(sum_p=0^inftyb_p^p)fn+1\n= ( 1 + frac12 + frac512^2 + )fn+1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the vector β = B_0 B_k contains the Adams-Bashford expansion coefficients, rational numbers generated numerically by the function fdiff_adams_bashford_expansion_polynom(k). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^kB_p^pfn\n=sum_p=0^kB_psum_j=0^p c_j^ifn-j\n= sum_j=0^kA_j^kfn-j\n= sum_j=0^kA_k-j^kfn-k+j","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the A_j^k= sum_p=j^k B_pc_j^p are the (k+1)-point Adams-Bashford integration weights.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Function:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"β = fdiff_adams_bashford_expansion_polynom(k)  B_0 B_k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"adams_bashford_weights = fdiff_expansion_weights(β, bwd, rev)   A_k^k A_0^k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"adams_bashford_weights = create_adams_bashford_weights(k)  A_k^k A_0^k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_adams_bashford_expansion_polynom(k::Int; T=Int, msg=true)\ncreate_adams_bashford_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"pages/manual/#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}","page":"Manual","title":"CamiDiff.fdiff_adams_bashford_expansion_polynom","text":"fdiff_adams_bashford_expansion_coeff(k::Int [; T=Int [, msg=true]])\nfdiff_adams_bashford_expansion_polynom(k::Int [; T=Int [, msg=true]])\n\n(k+1)-point Adams-Bashford expansion coefficients B_k equiv B_0^k B_k^k.  Note the forward vector ordering, which is the order of use in the summation below,\n\n-frac(1-)ln(1-)=sum_p=0^inftyB_p^p=1+ frac12+ frac512^2+ \n\nExamples:\n\njulia> o = fdiff_adams_bashford_expansion_polynom(5); println(o)\nRational{Int64}[1, 1//2, 5//12, 3//8, 251//720, 95//288]\n\njulia> fdiff_adams_bashford_expansion_coeff(0)\n1//1\n\njulia> fdiff_adams_bashford_expansion_coeff(5)\n95//288\n\njulia> fdiff_adams_bashford_expansion_coeff(20)\nInteger-overflow protection: output converted to BigInt\n8136836498467582599787//33720021833328230400000\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.create_adams_bashford_weights-Tuple{Int64}","page":"Manual","title":"CamiDiff.create_adams_bashford_weights","text":"create_adams_bashford_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Bashford weights vector b^k equivb_k^k b_0^k.  Note the reversed order, which corresponds to the order of use in the summation below,\n\nyn+1 = yn + frac1Dsum_j=0^kb^kjfn+1-k+j\n\nwhere b^kj equiv b_k-j^k. The b_j^k are the Adams-Bashford weight coefficients, with D the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\njulia> [create_adams_bashford_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [-1, 3])\n (2, 12, [5, -16, 23])\n (3, 24, [-9, 37, -59, 55])\n (4, 720, [251, -1274, 2616, -2774, 1901])\n (5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])\n\njulia> k = 5;\n\njulia> w = create_adams_bashford_weights(k; rationalize=true, devisor=true); println(w)\n(5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])\n\njulia> w = create_adams_bashford_weights(k; rationalize=true, devisor=false); println(w)\nRational{Int64}[-95//288, 959//480, -3649//720, 4991//720, -2641//480, 4277//1440]\n\njulia> w = create_adams_bashford_weights(k; rationalize=false); println(w)\n[-0.3298611111111111, 1.9979166666666666, -5.0680555555555555, 6.9319444444444445, -5.502083333333333, 2.970138888888889]\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#Adams-Moulton-expansion","page":"Manual","title":"Adams-Moulton expansion","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The Adams-Moulton integration step is given by the expansion","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"yn+1-yn\n= -fracln(1-)fn+1\n= ( 1 - frac12 - frac112^2 - frac124^3 +)fn+1","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"For the evaluation of the integration step we limit the summation to k+1 terms (order k),","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"yn+1-yn= (sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the vector β = b_0 b_k contains the Adams-Moulton expansion coefficients, rational numbers generated numerically by the function fdiff_adams_moulton_expansion_polynom(k). Extracting the greatest common denominator, 1D, the step becomes","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"yn+1-yn= frac1D(sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where b_0 b_k are integers and b_p=b_pD. In practice the expansion is restricted to k18 (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to k = 10). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"sum_p=0^kb_p^pfn\n=sum_p=0^kb_psum_j=0^p c_j^ifn-j\n= sum_j=0^ka_j^kfn-j\n= sum_j=0^ka_k-j^kfn-k+j","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"where the a_j^k= sum_p=j^k b_pc_j^p are the (k+1)-point Adams-Moulton integration weights.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"Functions:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"β = fdiff_adams_moulton_expansion_polynom(k)  b_0 b_k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"adams_moulton_weights = fdiff_expansion_weights(β, bwd, rev)  a_k^k a_0^k.","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"adams_moulton_weights = create_adams_moulton_weights(k)  a_k^k a_0^k","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"fdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)\ncreate_adams_moulton_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"pages/manual/#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}","page":"Manual","title":"CamiDiff.fdiff_adams_moulton_expansion_polynom","text":"fdiff_adams_moulton_expansion_coeff(k::Int; T=Int, msg=true)\nfdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)\n\nFinite difference expansion coefficient vector β  β_0(x)  β_k(x). Note the forward vector ordering, which is the order of use in the summation below,\n\n-fracln(1-)\n= sum_p=0^inftyβ_p^p\n= 1 - frac12 - frac112^2 - frac124^3 +\n\nExamples:\n\njulia> k = 5;\njulia> β = fdiff_adams_moulton_expansion_polynom(k); println(β)\nRational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]\n\njulia> fdiff_adams_moulton_expansion_coeff(k)\n-3//160\n\njulia> D = denominator(gcd(β))\n1440\n\njulia> convert(Vector{Int},(β .* D)); println(o)\n[1440, -720, -120, -60, -38, -27]\n\njulia> k = 20;\njulia> fdiff_adams_moulton_expansion_coeff(k)\nInteger-overflow protection: output converted to BigInt\n-12365722323469980029//4817145976189747200000\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.create_adams_moulton_weights-Tuple{Int64}","page":"Manual","title":"CamiDiff.create_adams_moulton_weights","text":"create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Moulton weights vector a^k equiva_k^k a_0^k.   Note the reversed vector ordering, which is the order of use in the summation below,\n\nyn+1 = yn + frac1Dsum_j=0^ka^kjfn+1-k+j\n\nwhere a^kj equiv a_k-j^k. The a_j^k are the Adams-Moulton weight coefficients and D is the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.\n\nExample:\n\njulia> [create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [1, 1])\n (2, 12, [-1, 8, 5])\n (3, 24, [1, -5, 19, 9])\n (4, 720, [-19, 106, -264, 646, 251])\n (5, 1440, [27, -173, 482, -798, 1427, 475])\n\njulia> k = 5;\njulia> w = create_adams_moulton_weights(k; rationalize=true, devisor=true); println(w)\n(5, 1440, [27, -173, 482, -798, 1427, 475])\n\njulia> w = create_adams_moulton_weights(k; rationalize=true, devisor=false); println(w)\nRational{Int64}[3//160, -173//1440, 241//720, -133//240, 1427//1440, 95//288]\n\njulia> w = create_adams_moulton_weights(k; rationalize=false); println(w)\n[0.01875, -0.12013888888888889, 0.3347222222222222, -0.5541666666666667, 0.9909722222222223, 0.3298611111111111]\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#Application","page":"Manual","title":"Application","text":"","category":"section"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"The three elementary operations are:","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"grid_interpolation(f, rval, grid)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"grid_differentiation(f, grid)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"grid_integration(f, grid)","category":"page"},{"location":"pages/manual/","page":"Manual","title":"Manual","text":"grid_interpolation(f::Vector{T}, rval::T, grid::Grid{T}; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}) where T<:Real","category":"page"},{"location":"pages/manual/#CamiDiff.grid_interpolation-Union{Tuple{T}, Tuple{Vector{T}, T, Grid{T}}} where T<:Real","page":"Manual","title":"CamiDiff.grid_interpolation","text":"grid_interpolation(f::Vector{T}, rval::T, grid::Grid{T}; k=5) where T<:Real\n\nInterpolated value for f(rval), with rval not on the Grid (rval ∉ grid.r).\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Manual","title":"CamiDiff.grid_differentiation","text":"grid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, itr::UnitRange; k=5) where T<:Real\n\nk^th-order lagrangian differentiation of the analytic function f(x), tabulated in forward order on a Grid of n points, f1n.\n\nExample:\n\njulia> grid = castGrid(3, 1001, Float64; h=2π/1000.0, r0=1.0, msg=true);\nGrid: linear (uniform), Float64, rmax = 6.28947, Ntot = 1001, p = 1, h = 0.00628319, r0 = 1.0\n\njulia> f = [sin(grid.r[i]) for i=1:grid.N]\n\njulia> g = [cos(grid.r[i]) for i=1:grid.N]\n\njulia> grid_differentiation(f, grid) ≈ g\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/manual/#CamiDiff.grid_integration-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Manual","title":"CamiDiff.grid_integration","text":"grid_integration(f::Vector{T}, grid::Grid{T}) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}, itr::UnitRange) where T<:Real\n\nIntegral of the analytic function f(r) tabulated on a generally nonlinear  Grid and evaluated with the generalized trapezoidal rule optimized  with endpoint correction by the weightsvector grid.epw,\n\n    _0^r_n f(r) dr = _0^n f(x) r^prime(x) dx\n\nHere, the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see trapezoidal_integration). The rule is exact for polynomial functions of degree d=0 1 k-1, where k= grid.epn. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples:\n\njulia> ftest(r) = sqrt(2.0/π) * exp(-r^2/2.0);\n\njulia> grid1 = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid created: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid2 = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);\nGrid created: quasi-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1\n\njulia> grid3 = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);\nGrid created: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1\n\njulia> grid4 = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);\nGrid created: polynomial, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001\n\njulia> r1 = grid1.r;\njulia> r2 = grid2.r;\njulia> r3 = grid3.r;\njulia> r4 = grid4.r;\njulia> f1 = [ftest(r1[n]) for n=1:grid1.N];\njulia> f2 = [ftest(r2[n]) for n=1:grid2.N];\njulia> f3 = [ftest(r3[n]) for n=1:grid3.N];\njulia> f4 = [ftest(r4[n]) for n=1:grid4.N];\njulia> o1 = grid_integration(f1, grid1);\njulia> o2 = grid_integration(f2, grid2);\njulia> o3 = grid_integration(f3, grid3, 1:900);\njulia> o4 = grid_integration(f4, grid4, 1:900);\n\njulia> println(\"integral on \" * grid1.name * \" grid = \", o1)\nintegral on exponential grid = 1.0\n\njulia> println(\"integral on \" * grid2.name * \" grid = \", o2)\nintegral on quasi-exponential grid: 1.0\n\njulia> println(\"integral on \" * grid3.name * \" grid = \", o3)\nintegral on linear (uniform) grid = 1.000000000000003\n\njulia> println(\"integral on \" * grid3.name * \" grid = \", o4)\nintegral on polynomial grid = 1.0000000000000013\n\n\n\n\n\n","category":"method"}]
}
