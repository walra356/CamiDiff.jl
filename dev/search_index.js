var documenterSearchIndex = {"docs":
[{"location":"pages/application/#Application","page":"Application","title":"Application","text":"","category":"section"},{"location":"pages/application/","page":"Application","title":"Application","text":"The three elementary operations are:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"grid_interpolation(f, rval, grid)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"grid_differentiation(f, grid)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"grid_integration(f, grid)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"grid_interpolation(f::Vector{T}, rval::T, grid::Grid{T}; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}) where T<:Real","category":"page"},{"location":"pages/application/#CamiDiff.grid_interpolation-Union{Tuple{T}, Tuple{Vector{T}, T, Grid{T}}} where T<:Real","page":"Application","title":"CamiDiff.grid_interpolation","text":"grid_interpolation(f::Vector{T}, rval::T, grid::Grid{T}; k=5) where T<:Real\n\nInterpolated value for f(rval), with rval not on the Grid (rval ∉ grid.r).\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Application","title":"CamiDiff.grid_differentiation","text":"grid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, itr::UnitRange; k=5) where T<:Real\n\nk^th-order lagrangian differentiation of the analytic function f(x), tabulated in forward order on a Grid of n points, f1n.\n\nExample:\n\njulia> grid = castGrid(3, 1001, Float64; h=2π/1000.0, r0=1.0, msg=true);\nGrid: linear (uniform), Float64, rmax = 6.28947, Ntot = 1001, p = 1, h = 0.00628319, r0 = 1.0\n\njulia> f = [sin(grid.r[i]) for i=1:grid.N]\n\njulia> g = [cos(grid.r[i]) for i=1:grid.N]\n\njulia> grid_differentiation(f, grid) ≈ g\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.grid_integration-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Application","title":"CamiDiff.grid_integration","text":"grid_integration(f::Vector{T}, grid::Grid{T}) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}, itr::UnitRange) where T<:Real\n\nIntegral of the analytic function f(r) tabulated on a generally nonlinear  Grid and evaluated with the generalized trapezoidal rule optimized  with endpoint correction by the weightsvector grid.epw,\n\n    _0^r_n f(r) dr = _0^n f(x) r^prime(x) dx\n\nHere, the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see trapezoidal_integration). The rule is exact for polynomial functions of degree d=0 1 k-1, where k= grid.epn. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples:\n\njulia> ftest(r) = sqrt(2.0/π) * exp(-r^2/2.0);\n\njulia> grid1 = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid created: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid2 = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);\nGrid created: quasi-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1\n\njulia> grid3 = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);\nGrid created: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1\n\njulia> grid4 = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);\nGrid created: polynomial, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001\n\njulia> r1 = grid1.r;\njulia> r2 = grid2.r;\njulia> r3 = grid3.r;\njulia> r4 = grid4.r;\njulia> f1 = [ftest(r1[n]) for n=1:grid1.N];\njulia> f2 = [ftest(r2[n]) for n=1:grid2.N];\njulia> f3 = [ftest(r3[n]) for n=1:grid3.N];\njulia> f4 = [ftest(r4[n]) for n=1:grid4.N];\njulia> o1 = grid_integration(f1, grid1);\njulia> o2 = grid_integration(f2, grid2);\njulia> o3 = grid_integration(f3, grid3, 1:900);\njulia> o4 = grid_integration(f4, grid4, 1:900);\n\njulia> println(\"integral on \" * grid1.name * \" grid = \", o1)\nintegral on exponential grid = 1.0\n\njulia> println(\"integral on \" * grid2.name * \" grid = \", o2)\nintegral on quasi-exponential grid: 1.0\n\njulia> println(\"integral on \" * grid3.name * \" grid = \", o3)\nintegral on linear (uniform) grid = 1.000000000000003\n\njulia> println(\"integral on \" * grid3.name * \" grid = \", o4)\nintegral on polynomial grid = 1.0000000000000013\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#Lagrange-polynomial-interpolation/extrapolation","page":"Application","title":"Lagrange-polynomial interpolation/extrapolation","text":"","category":"section"},{"location":"pages/application/","page":"Application","title":"Application","text":"The Lagrange polynomial of degree k on a uniform grid is the polynomial running through  k+1 subsequent points on the grid. We derive expressions for interpolation/extrapolation  in both forward- and backward-difference notation. Beware that Lagrange interpolation  becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Forward difference notation","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Starting from the relation","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn=(1+Δ)fn+1","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"we obtain by formal operator inversion","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+1 = (1 + Δ)^-1 fn  sum_p=0^infty(-1)^p Δ^p fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+2 = (1 + Δ)^-2 fn  sum_p=0^infty(-1)^p pΔ^p fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"vdots","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where p is called the order of the expansion and n is the index of the reference position. For interpolation position n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn-σ = (1 + Δ)^-σ fn  sum_p=0^infty α_p(σ) Δ^p fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"α_p(σ)  (-1)^p(σ)_pp","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"is the p^th-order finite-difference expansion coefficient for lagrangian lagrangian interpolation over the interval -k σ 0  (n le n-σ le n+k),","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"(σ)_p=begincases\n1  p=0\nσ(σ+1)(σ+2)cdots(σ+p-1)  p0\nendcases","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"being the Pochhammer symbol CamiMath.pochhammer. For σ outside  the interpolation interval the method corresponds to extrapolation along the Lagrange polynomial. Evaluating the finite-difference expansion up to order k we obtain  ","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn-σ =sum_p=0^kα_p(σ)Δ^pfn\n=sum_j=0^kF_j^k(σ)fn+j\n=F^k(σ) cdot fnn+k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the k+1 weights","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"F_j^k(σ)= sum_p=j^k (-1)^k α_p(σ) c_j^p\n=sum_p=j^k (-1)^j binompj(σ)_pp","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"are the lagrangian interpolation weights corresponding to the point fn-σ.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Symmetry relation:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"barF^k(-k-σ) = F^k(σ)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Weight functions:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_expansion_weights(polynom, fwd, reg)  F^k(σ)  F^k_0(σ) F^k_k,","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the vector","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"polynom =fdiff_interpolation_expansion_polynom(σ, k, fwd)  α(σ)  α_0(σ) α_k(σ)  contains the coefficients of the lagrangian-interpolation expansion.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Backward difference notation","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Starting from the relation","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn=(1-)fn+1","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"we obtain by formal operator inversion","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+1 = (1 - )^-1 fn  sum_p=0^infty^p fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+2 = (1 - )^-2 fn  sum_p=0^inftyp^p fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"vdots","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where k is called the order of the expansion and n is the reference index. For interpolation position n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+σ = (1 - )^-σ fn  sum_p=0^infty β_p(σ) ^p fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"β_p(σ)  (σ)_pp = (-1)^p α_p(σ)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"is the p^th-order finite-difference expansion coefficient for lagrangian interpolation over the interval -k σ 0  (n-k le n+σ le n), with","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"(σ)_p=begincases\n1  p=0\nσ(σ+1)(σ+2)cdots(σ+p-1)  p0\nendcases","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"being the Pochhammer symbol CamiMath.pochhammer. For σ outside  the interpolation interval the method corresponds to extrapolation along the Lagrange polynomial. Evaluating the finite-difference expansion up to order k we obtain","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+σ =sum_p=0^kβ_p(σ)^pfn\n= sum_j=0^kB^k_j(σ)fn-j\n= barB^k(σ)  fn-kn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the k+1 weights","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"B^k_j(σ)= sum_p=j^k β_p(σ) c_j^p","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"are the corresponding lagrangian interpolation weights.  ","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Symmetry relations:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"B^k(σ) = F^k(σ) = barB^k(-k-σ)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"barB^k(σ) = B^k(-k-σ)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Weight function:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_expansion_weights(polynom, bwd, rev)  barB^k(σ)  B_k^k(σ) B_0^k(σ),","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the vector","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"polynom =fdiff_interpolation_expansion_polynom(σ, k=3, notation=bwd)  β(σ)  β_0(σ) β_k(σ) contains the coefficients of the lagrangian-interpolation expansion.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_interpolation_expansion_polynom(ξ::T, k=3, notation=CamiMath.bwd) where T<:Real\nfdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}","category":"page"},{"location":"pages/application/#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Application","title":"CamiDiff.fdiff_interpolation_expansion_polynom","text":"fdiff_interpolation_expansion_polynom(ξ::T [, k=3 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining the k^th-order (default third order) Lagrange-polynomial interpolation of a tabulated analytic function fn at offset ξ with respect to index position n, which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nIn this case we consider the tabulated interval fnn+k. The interpolated value fn+ξ is given by the forward-difference expansion\n\nfn+ξ = sum_p=0^k α_p(-ξ) Δ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(ξ, k, fwd)  α(-ξ)  α_0(-ξ) α_k(-ξ). In this notation the range 0leq ξleq k corresponds to interpolation and the ranges ξ0 and ξk to extrapolation.\n\nBackward difference notation (notation = bwd)\n\nIn this case we consider the tabulated interval fn-kn. The interpolated value fn+ξ is given by the backward-difference expansion\n\nfn+ξ = sum_p=0^k β_p(ξ) ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(ξ, k, bwd)  β(ξ)  β_0(ξ) β_k(ξ). In this notation the range -kleq ξleq0 corresponds to interpolation and the ranges ξ-k and ξ0 to extrapolation.\n\nExamples:\n\nk = 5\nξ = -1\nα = fdiff_interpolation_expansion_polynom(ξ, k, fwd); println(\"α = $α\")\nβ = fdiff_interpolation_expansion_polynom(ξ, k, bwd); println(\"β = $β\")\n  α = [1, 1, 0, 0, 0, 0]\n  β = [1, 1, 1, 1, 1, 1]\n\nξ = 0\nα = fdiff_interpolation_expansion_polynom(ξ, k, fwd); println(\"α = $α\")\nβ = fdiff_interpolation_expansion_polynom(ξ, k, bwd); println(\"β = $β\")\n  α = [1, 0, 0, 0, 0, 0]\n  β = [1, 0, 0, 0, 0, 0]\n\nξ = 1\nα = fdiff_interpolation_expansion_polynom(ξ, k, fwd); println(\"α = $α\")\nβ = fdiff_interpolation_expansion_polynom(ξ, k, bwd); println(\"β = $β\")\n  α = [1, -1, 1, -1, 1, -1]\n  β = [1, -1, 0, 0, 0, 0]\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T<:Real, V<:Real}","page":"Application","title":"CamiDiff.fdiff_interpolation","text":"fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}\n\nFinite difference lagrangian interpolation (by default third order) at real position v (in index units) with respect to the elements of the uniformly tabulated analytic function f[1:N]. The interpolation points are situated on a Lagrange polynomial of degree k (by default third degree) running through k+1 subsequenct points of the tabulated function. Outside the tabulated range, the method represents extrapolation on the lagrangian polynomial defined by the first/last k+1 tabulated points.\n\nBeware that the interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.\n\nExamples:\n\nf = [1,2,3,4,5,6,7]\n[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]\n  [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]\n\nf = [1,4,9,16,25,36,49]\n[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]\n [1.0, 2.25, 4.0, 6.25, 9.0, 12.25, 16.0, 20.25, 25.0, 30.25, 36.0, 42.25, 49.0]\n\n f = [x^3 for x=-4:2]\n f1(v) = fdiff_interpolation(f, v; k=1)\n f2(v) = fdiff_interpolation(f, v; k=2)\n f3(v) = fdiff_interpolation(f, v; k=3)\n [[f1(v),f2(v),f3(v)] for v=1:0.5:9]\n   [[-64.0, -64.0, -64.0], [-45.5, -43.25, -42.875], [-27.0, -27.0, -27.0],\n   [-17.5, -16.0, -15.625], [-8.0, -8.0, -8.0], [-4.5, -3.75, -3.375],\n   [-1.0, -1.0, -1.0], [-0.5, -0.5, -0.125], [0.0, 0.0, 0.0],\n   [0.5, -0.25, 0.125], [1.0, 1.0, 1.0], [4.5, 3.75, 3.375], [8.0, 8.0, 8.0],\n   [11.5, 13.75, 15.625], [15.0, 21.0, 27.0], [18.5, 29.75, 42.875],\n   [22.0, 40.0, 64.0]]\n\nThe result for f3(v) is exact because the function is cubic and the expansion is third order - see Figure below. The tabulated function is given by the black points. The interpolation and extrapolation points are red.\n\n(Image: Image)\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#Lagrangian-differentiation","page":"Application","title":"Lagrangian differentiation","text":"","category":"section"},{"location":"pages/application/","page":"Application","title":"Application","text":"To derive the lagrangian differentiation formulas we formally differentiate","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fn+x = (1 - )^-x fn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"with respect to x,","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fracdfdxn+x\n=-ln(1-) (1-)^-xfn\n=sum_q=1^ktfrac1q^qsum_p=0^kl_p(x)^pfn+","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Rewriting the r.h.s. as a single expansion in powers of , we obtain","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fracdfdxn+x=sum_p=1^kβ_p(x)^pfn+","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where β_p(x) represents the finite-difference expansion coefficients for lagrangian differentiation at position n+x. The coefficients β_p(x)  are obtained by polynomial multiplication using the function CamiMath.polynom_product(p1,p2),  where p_1 and p_2 are CamiMath.polynom vectors.  The resulting coefficients are contained in the following CamiMath.polynom vector of order k, ","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_differentiation_expansion_polynom(k,x)  β(x)  β_0(x) β_p(x), with β_0(x) 0.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Substituting the finite-difference operators, the lagrangian derivative takes the form  ","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fracdfdxn+x\n=sum_j=0^kB_j^k(x)fn-j\n=B^k(x)  fn-1n-k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the k+1 weights","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":" B_j^k(x)=sum_p=j^kβ_p(x)c_j^p","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"are the k^th-order lagrangian-differentiation weights","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_expansion_weights(β, bwd, reg)  B^k(x)  B^k_0(x) B^k_k(x).","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"After changing dummy index to reverse the summation the expansion becomes","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fracdfdxn+x\n=sum_j=0^kbarB^k_j(x)fn-k+j\n=barB^k(x)  fn-kn","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_expansion_weights(β, bwd, rev)  barB^k(x)  B^k_k(x) B^k_0(x).","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_differentiation_expansion_polynom(ξ::T, k=3) where T<:Real\ncreate_lagrange_differentiation_matrix(k::Int)","category":"page"},{"location":"pages/application/#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T<:Real","page":"Application","title":"CamiDiff.fdiff_differentiation_expansion_polynom","text":"fdiff_differentiation_expansion_polynom(ξ::T [, k=3 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining k^th-order lagrangian differentiation of the tabulated analytic function fn at offset ξ (with respect to index position n), which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nfracdfdξn+ξ=sum_p=0^kα_p(ξ)Δ^pfn\n\nOffset convention: ξ = -σ with respect to index n in tabulated interval fnn+k\n\nBackward difference notation (notation = bwd)\n\nfracdfdξn+ξ=sum_p=0^kβ_p(ξ)^pfn\n\nwhere β(ξ)  β_0(ξ)  β_p(ξ)\n\nOffset convention: ξ = σ with respect to index n in tabulated interval fn-kn\n\nExample:\n\nk = 2; ξ = 0\no = fdiff_differentiation_expansion_polynom(ξ, k); println(o)\n [0.0, 1.0, -1.5]\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}","page":"Application","title":"CamiDiff.create_lagrange_differentiation_matrix","text":"create_lagrange_differentiation_matrix(k::Int)\n\nLagrange differentiation matrix, mij=s_k-j^k(i), for k^th-order lagrangian differentiation,\n\nfracdydxi= sum_j=0^kmijyj\n\nExample:\n\nk = 3\ncreate_lagrange_differentiation_matrix(k)\n 4×4 Matrix{Rational{Int64}}:\n  -11//6   3//1  -3//2   1//3\n   -1//3  -1//2   1//1  -1//6\n    1//6  -1//1   1//2   1//3\n   -1//3   3//2  -3//1  11//6\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#Integration","page":"Application","title":"Integration","text":"","category":"section"},{"location":"pages/application/","page":"Application","title":"Application","text":"trapezoidal_epw(k::Int; rationalize=false, devisor=false)\ntrapezoidal_integration(f, x1, x2, weights)","category":"page"},{"location":"pages/application/#CamiDiff.trapezoidal_epw-Tuple{Int64}","page":"Application","title":"CamiDiff.trapezoidal_epw","text":"trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])\n\nEndpoint weights vector a=a_1 a_k of trapeziodal rule optimized for functions of polynomial form,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nwhere k is odd. The rule is exact for polynonials of degree d=0 1  k-1. For k=1 the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\n[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]\n5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n  (1, 2, [1])\n  (3, 24, [9, 28, 23])\n  (5, 1440, [475, 1902, 1104, 1586, 1413])\n  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])\n  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,\n                                                     5095890, 7783754, 7200319])\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.trapezoidal_integration-NTuple{4, Any}","page":"Application","title":"CamiDiff.trapezoidal_integration","text":"trapezoidal_integration(f, x1, x2, weights)\n\nIntegral of the tabulated function f=f_0 f_n over the domain x1  x  x2 using the optimized trapezoidal rule with endpoint correction by the weights vector weights,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nThe rule is exact for polynonials of degree d=0 1 k-1. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples::\n\np = 3\nc = [1 for i=0:p]\npol = ImmutablePolynomial(c,:z)\nIpol = integrate(pol)\nn = 10\n\nx1=0.0\nx2=5.0\nx = collect(range(x1, x2, n))\nf = pol.(x .-2.5)\n\nw3 = trapezoidal_epw(3)\ntrapezoidal_integration(f, x1, x2, w3)\n 15.416666666666673\n\nIpol(2.5)-Ipol(-2.5)\n 15.41666666666666\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#Adams-Method","page":"Application","title":"Adams Method","text":"","category":"section"},{"location":"pages/application/#Adams-Bashford-expansion","page":"Application","title":"Adams-Bashford expansion","text":"","category":"section"},{"location":"pages/application/","page":"Application","title":"Application","text":"The Adams-Bashford integration step is given by the expansion","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"yn+1-yn = -frach (1-)ln(1-)fn+1=h (sum_p=0^inftyB_p^p)fn+1","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"A closed expression for the Adams-Bashford expansion coefficients, B_k, is not available. As we already have a finite-difference expansion for the operator (1-)^-1,","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"frac11-sum_p=0^infty^p","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"we ask for the expansion of","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"-fracln(1-)\n=(1-frac12-frac124^2-frac112^3+)fn+1\n= (sum_p=0^inftyb_p^p)fn+1","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"This is known as the Adams-Moulton expansion. Its expansion coefficients are calculated numerically by the function fdiff_adams_moulton_expansion_polynom(k). The Adams-Bashford expansion is obtained as the polynomial product of the two expansions,","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"(sum_p=0^inftyB_p^p)fn+1\n=(sum_p=0^infty^p)(sum_p=0^inftyb_p^p)fn+1\n= ( 1 + frac12 + frac512^2 + )fn+1","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the vector β = B_0 B_k contains the Adams-Bashford expansion coefficients, rational numbers generated numerically by the function fdiff_adams_bashford_expansion_polynom(k). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"sum_p=0^kB_p^pfn\n=sum_p=0^kB_psum_j=0^p c_j^ifn-j\n= sum_j=0^kA_j^kfn-j\n= sum_j=0^kA_k-j^kfn-k+j","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the A_j^k= sum_p=j^k B_pc_j^p are the (k+1)-point Adams-Bashford integration weights.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Function:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"β = fdiff_adams_bashford_expansion_polynom(k)  B_0 B_k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"adams_bashford_weights = fdiff_expansion_weights(β, bwd, rev)   A_k^k A_0^k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"adams_bashford_weights = create_adams_bashford_weights(k)  A_k^k A_0^k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_adams_bashford_expansion_polynom(k::Int; T=Int, msg=true)\ncreate_adams_bashford_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"pages/application/#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}","page":"Application","title":"CamiDiff.fdiff_adams_bashford_expansion_polynom","text":"fdiff_adams_bashford_expansion_coeff(k::Int [; T=Int [, msg=true]])\nfdiff_adams_bashford_expansion_polynom(k::Int [; T=Int [, msg=true]])\n\n(k+1)-point Adams-Bashford expansion coefficients B_k equiv B_0^k B_k^k.  Note the forward vector ordering, which is the order of use in the summation below,\n\n-frac(1-)ln(1-)=sum_p=0^inftyB_p^p=1+ frac12+ frac512^2+ \n\nExamples:\n\njulia> o = fdiff_adams_bashford_expansion_polynom(5); println(o)\nRational{Int64}[1, 1//2, 5//12, 3//8, 251//720, 95//288]\n\njulia> fdiff_adams_bashford_expansion_coeff(0)\n1//1\n\njulia> fdiff_adams_bashford_expansion_coeff(5)\n95//288\n\njulia> fdiff_adams_bashford_expansion_coeff(20)\nInteger-overflow protection: output converted to BigInt\n8136836498467582599787//33720021833328230400000\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.create_adams_bashford_weights-Tuple{Int64}","page":"Application","title":"CamiDiff.create_adams_bashford_weights","text":"create_adams_bashford_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Bashford weights vector b^k equivb_k^k b_0^k.  Note the reversed order, which corresponds to the order of use in the summation below,\n\nyn+1 = yn + frac1Dsum_j=0^kb^kjfn+1-k+j\n\nwhere b^kj equiv b_k-j^k. The b_j^k are the Adams-Bashford weight coefficients, with D the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\njulia> [create_adams_bashford_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [-1, 3])\n (2, 12, [5, -16, 23])\n (3, 24, [-9, 37, -59, 55])\n (4, 720, [251, -1274, 2616, -2774, 1901])\n (5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])\n\njulia> k = 5;\n\njulia> w = create_adams_bashford_weights(k; rationalize=true, devisor=true); println(w)\n(5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])\n\njulia> w = create_adams_bashford_weights(k; rationalize=true, devisor=false); println(w)\nRational{Int64}[-95//288, 959//480, -3649//720, 4991//720, -2641//480, 4277//1440]\n\njulia> w = create_adams_bashford_weights(k; rationalize=false); println(w)\n[-0.3298611111111111, 1.9979166666666666, -5.0680555555555555, 6.9319444444444445, -5.502083333333333, 2.970138888888889]\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#Adams-Moulton-expansion","page":"Application","title":"Adams-Moulton expansion","text":"","category":"section"},{"location":"pages/application/","page":"Application","title":"Application","text":"The Adams-Moulton integration step is given by the expansion","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"yn+1-yn\n= -fracln(1-)fn+1\n= ( 1 - frac12 - frac112^2 - frac124^3 +)fn+1","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"For the evaluation of the integration step we limit the summation to k+1 terms (order k),","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"yn+1-yn= (sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the vector β = b_0 b_k contains the Adams-Moulton expansion coefficients, rational numbers generated numerically by the function fdiff_adams_moulton_expansion_polynom(k). Extracting the greatest common denominator, 1D, the step becomes","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"yn+1-yn= frac1D(sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where b_0 b_k are integers and b_p=b_pD. In practice the expansion is restricted to k18 (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to k = 10). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"sum_p=0^kb_p^pfn\n=sum_p=0^kb_psum_j=0^p c_j^ifn-j\n= sum_j=0^ka_j^kfn-j\n= sum_j=0^ka_k-j^kfn-k+j","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"where the a_j^k= sum_p=j^k b_pc_j^p are the (k+1)-point Adams-Moulton integration weights.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"Functions:","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"β = fdiff_adams_moulton_expansion_polynom(k)  b_0 b_k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"adams_moulton_weights = fdiff_expansion_weights(β, bwd, rev)  a_k^k a_0^k.","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"adams_moulton_weights = create_adams_moulton_weights(k)  a_k^k a_0^k","category":"page"},{"location":"pages/application/","page":"Application","title":"Application","text":"fdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)\ncreate_adams_moulton_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"pages/application/#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}","page":"Application","title":"CamiDiff.fdiff_adams_moulton_expansion_polynom","text":"fdiff_adams_moulton_expansion_coeff(k::Int; T=Int, msg=true)\nfdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)\n\nFinite difference expansion coefficient vector β  β_0(x)  β_k(x). Note the forward vector ordering, which is the order of use in the summation below,\n\n-fracln(1-)\n= sum_p=0^inftyβ_p^p\n= 1 - frac12 - frac112^2 - frac124^3 +\n\nExamples:\n\njulia> k = 5;\njulia> β = fdiff_adams_moulton_expansion_polynom(k); println(β)\nRational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]\n\njulia> fdiff_adams_moulton_expansion_coeff(k)\n-3//160\n\njulia> D = denominator(gcd(β))\n1440\n\njulia> convert(Vector{Int},(β .* D)); println(o)\n[1440, -720, -120, -60, -38, -27]\n\njulia> k = 20;\njulia> fdiff_adams_moulton_expansion_coeff(k)\nInteger-overflow protection: output converted to BigInt\n-12365722323469980029//4817145976189747200000\n\n\n\n\n\n","category":"method"},{"location":"pages/application/#CamiDiff.create_adams_moulton_weights-Tuple{Int64}","page":"Application","title":"CamiDiff.create_adams_moulton_weights","text":"create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Moulton weights vector a^k equiva_k^k a_0^k.   Note the reversed vector ordering, which is the order of use in the summation below,\n\nyn+1 = yn + frac1Dsum_j=0^ka^kjfn+1-k+j\n\nwhere a^kj equiv a_k-j^k. The a_j^k are the Adams-Moulton weight coefficients and D is the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.\n\nExample:\n\njulia> [create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [1, 1])\n (2, 12, [-1, 8, 5])\n (3, 24, [1, -5, 19, 9])\n (4, 720, [-19, 106, -264, 646, 251])\n (5, 1440, [27, -173, 482, -798, 1427, 475])\n\njulia> k = 5;\njulia> w = create_adams_moulton_weights(k; rationalize=true, devisor=true); println(w)\n(5, 1440, [27, -173, 482, -798, 1427, 475])\n\njulia> w = create_adams_moulton_weights(k; rationalize=true, devisor=false); println(w)\nRational{Int64}[3//160, -173//1440, 241//720, -133//240, 1427//1440, 95//288]\n\njulia> w = create_adams_moulton_weights(k; rationalize=false); println(w)\n[0.01875, -0.12013888888888889, 0.3347222222222222, -0.5541666666666667, 0.9909722222222223, 0.3298611111111111]\n\n\n\n\n\n","category":"method"},{"location":"pages/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"pages/","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CamiDiff","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiDiff.jl is a Julia package for one-dimensional finite-difference analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is installed using the Julia package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"CamiDiff\")\n\njulia> using CamiDiff","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiDiff has been developped to study continuously differentiable functions, provided by the user in tabulated form.  The package is based on the methods of finite-difference analysis in one dimension. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Throughout the documentation f(x) will be our function of interest under investigation. The tabulated form can be regarded as  the result of discretization of f(x), onto a Grid of N points, addressable by the gridindex n = 1  N. The Grid can be linear or non-linear as specified by a gridfunction - see Discretization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current implementation of CamiDiff was developped for real functions of a single variable, using  gridfunctions restricted to the domain 0 ). A set of four predefined gridtypenames is included: 'exponential',  'quasi-exponential', 'linear' and 'polynomial'. To underline the restriction to the non-negative domain, we shall often  use the variable r rather than x, writing f(r) rather than f(x), with the implicit condition r  0.","category":"page"},{"location":"#Discretization","page":"Home","title":"Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mathematically, the discretization is based on the map n  x which defines the discrete function","category":"page"},{"location":"","page":"Home","title":"Home","text":"xn = s_0 * g(tn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here g(t) is called the gridfunction and s_0 the scaling factor. The gridfunction  is defined as a (generally nonlinear) function running through the origin: g(0) = 0. Its argument is  the ticks function","category":"page"},{"location":"","page":"Home","title":"Home","text":"tn  (nu) * h","category":"page"},{"location":"","page":"Home","title":"Home","text":"which is a discrete linear function, where u is called the index base and h the step size. Writing","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn = f(xn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"we recognize in fn a discrete function representing the function f(x) at position xn. This represents  the tabulated that has to be provided by the user","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that h determines the coarseness of the Grid. The results of a finite-difference calculation  on a coarse grid will be less accurate than those on a fine grid, but the algorithm is identical, because the relevant finite-difference expansions only depend on h implicitely. Since Julia uses  unit-based indexing (u = 1), the index convention implies f1 = f(0).  ","category":"page"},{"location":"#Grid","page":"Home","title":"Grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Grid object is the backbone for the numerical procedure on a (generally) non-uniform grid. Its principal fields are grid.r, grid.r′ and grid.r′′ which are discrete functions of N elements representing the grid function and its first two derivatives.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the Grid is specified, three basic operations are at our disposal - see Application","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_interpolation(f, rval, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_differentiation(f, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_integration(f, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid{T}\ncastGrid(ID::Int, N::Int, T::Type; h=1, r0=0.001,  p=5, polynom=[0,1], epn=5, k=7, msg=true)\ngridfunction(ID::Int, n::Int, h::T; p=5, polynom=[0,1], deriv=0) where T <: Real\ngridtypename(ID::Int)\ngridtypeID(name::String)\ngridPos(rval::T, grid::Grid{T}) where T<:Real\nfracPos(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T<:Real","category":"page"},{"location":"#CamiDiff.Grid","page":"Home","title":"CamiDiff.Grid","text":"Grid(ID, name, T, N, r, r′, r′′, h, r0, epn, epw, k, p, polynom)\n\nType with fields:\n\n.ID:    grid identifer name (::Int)\n.name:  grid identifer name (::String)\n.T:     gridtypename (::Type)\n.N:     number of grid points (::Int)\n.r:   tabulated grid function (::Vector{T})\n.r′:   tabulated first derivative of grid function (::Vector{T})\n.r′′:   tabulated second derivative of grid function (::Vector{T})\n.h :    grid step multiplyer (::T)\n.r0:    grid scale factor (::T)\n.epn:   number of endpoints used for trapezoidal endpoint correction (must be odd) (::Int)\n.epw:   trapezoidal endpoint weights for n=1:epn (::Vector{Vector{T}})\n.k:     finite-difference order (::Int)\n.p:     only for quasi-exponential grid; truncation power (::Int)\n.polynom: only for polynomial grid: polynom (::Vector{T})\n\nThe object Grid is best created with the function castGrid.\n\n\n\n\n\n","category":"type"},{"location":"#CamiDiff.castGrid-Tuple{Int64, Int64, Type}","page":"Home","title":"CamiDiff.castGrid","text":"castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, polynom=[0,1], epn=5, k=7, msg=false)\ncastGrid(name::String, N::Int, T::Type; h=1, r0=1, p=5, polynom=[0,1], epn=5, k=7, msg=false)\n\nMethod to create the Grid object\n\nID = 1: exponential, ID = 2: quasi-exponential, ID = 3: linear (uniform) ID = 4: polynomial\n\nExamples:\n\njulia> grid = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid = castGrid(\"exponential\", 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);\nGrid: quasi-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1\n\njulia> grid = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);\nGrid: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1\n\njulia> grid = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);\nGrid: polynomial of degree 2, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001\n\njulia> grid.r[1:4]\n4-element Vector{Float64}:\n [2.220446049250313e-16, 1.0000000000000003e-5, 4.000000000000001e-5, 9.000000000000003e-5]\n\njulia> grid.r′[1:4]\n4-element Vector{Float64}:\n [0.0, 2.0000000000000005e-5, 4.000000000000001e-5, 6.0000000000000015e-5]\n \njulia> grid.r′′[1:4]\n4-element Vector{Float64}:\n [2.0000000000000005e-5, 2.0000000000000005e-5, 2.0000000000000005e-5, 2.0000000000000005e-5] \n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T<:Real","page":"Home","title":"CamiDiff.gridfunction","text":"gridfunction(ID::Int, n::Int, h::T; p=5, polynom=[0,1], deriv=0) where T <: Real\n\nCamiDiff offers three internal gridfunctions:\n\nID = 1: exponential grid function,\n\n    g(t) = e^t - 1\n\nID = 2: quasi-exponential grid function of degree p (linear grid for p = 1),\n\n    g(t) = t + frac12t^2 +  + frac1pt^p\n\nID = 3: linear grid function,\n\n    g(t) = t\n\nID = 4: polynomial grid function of degree p = length(c)-1 defined by its CamiMath.polynom vector c = c_0 c_1c_2 c_p,\n\n    g(t) = c_0 + c_1 t + c_2 t^2 +  + c_p t^p\n\nwith c_0  0 because, by definition, all grid functions run through the origin, g(0) = 0. \n\nThe actual grid is given by \n\n    xn = r_0 * g(tn)\n\nwhere tn = (n-1) * h is the ticks function for the unit-based indexing of Julia.\n\nNB. Note that t1 = 0 and x1 = 0 for all grid functions.\n\nExamples:\n\njulia> h = 0.1; r0=1.0; N=4;\n\njulia> r = r0 .* [gridfunction(1, n-1, h) for n=1:N]\n[0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]\n\njulia> r′ = r0 .* [gridfunction(1, n-1, h; deriv=1) for n=1:N]\n[0.1, 0.11051709180756478, 0.122140275816017, 0.13498588075760032]\n\njulia> r′′= r0 .* [gridfunction(1, n-1, h; deriv=2) for n=1:N]\n[0.010000000000000002, 0.011051709180756479, 0.012214027581601701, 0.013498588075760034]\n\njulia> r = r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1]) for n=1:N]\n[0.0, 0.010000000000000002, 0.04000000000000001, 0.09000000000000002]\n\njulia> r′ = r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1], deriv=1) for n=1:N]\n[0.0, 0.020000000000000004, 0.04000000000000001, 0.06000000000000001]\n\njulia> r′′= r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1], deriv=2) for n=1:N]\n[0.020000000000000004, 0.020000000000000004, 0.020000000000000004, 0.020000000000000004]\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridtypename-Tuple{Int64}","page":"Home","title":"CamiDiff.gridtypename","text":"gridtypename(ID::Int)\n\nName corresponding to the Grid ID.\n\nExample:\n\njulia> gridtypename(2)\n\"quasi-exponential\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridtypeID-Tuple{String}","page":"Home","title":"CamiDiff.gridtypeID","text":"gridtypeID(name::String)\n\nID corresponding to the gridtypename.\n\nExample:\n\njulia> gridtypeID(\"quasi-exponential\")\n2\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridPos-Union{Tuple{T}, Tuple{T, Grid{T}}} where T<:Real","page":"Home","title":"CamiDiff.gridPos","text":"gridPos(rval::T, grid::Grid{T}) where T<:Number\n\nThe approximate grid position defined as the largest integer n satisfying the  condition grid.r[n] < rval on the Grid.\n\nExample:\n\njulia> h = 0.1; r0 = 1.0;\n\njulia> grid = castGrid(1, 4, Float64; h, r0);\n\njulia> r = grid.r; println(\"r[3] = $(r[3])\")\nr[3] = 0.22140275816016985\n\njulia> gridPos(0.222, grid)\n3\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.fracPos-Union{Tuple{T}, Tuple{Int64, T, Grid{T}}} where T<:Real","page":"Home","title":"CamiDiff.fracPos","text":"fracPos(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T<:Real\n\nFractional grid offset with respect to Grid position n.\n\n\n\n\n\n","category":"method"},{"location":"#Finite-differences","page":"Home","title":"Finite differences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Having discretized the analytic function f(x), one defines finite differences.  The forward difference of f(x+h) and f(x) is defined by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Δ f(x)=f(x+h)-f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, Δ is called the forward-difference operator. Likewise one defines backward differences  with the backward-difference operator , ","category":"page"},{"location":"","page":"Home","title":"Home","text":" f(x)=f(x)-f(x-h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We first focus on forward differences. The derivative of f(x) is given by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f^(x)=underseth0mathrmlimfracf(x+h)-f(x)h=undersetΔ x0mathrmlimfracΔ f(x)Δ x","category":"page"},{"location":"","page":"Home","title":"Home","text":"where h  Δx  0 is the difference interval. Introducing the differential operator, f^(x)  Df(x), we have ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dfracddx=undersetΔ x0mathrmlimfracΔΔ x=underseth0mathrmlimfracΔh","category":"page"},{"location":"#Translation-operators","page":"Home","title":"Translation operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"With regard to forward differences we rewrite the forward difference definition in the form of a forward translation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x+h)=(1+Δ)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where T(1+Δ) is the forward translation operator. This operator shifts the function over the infinitesimal interval h to larger values of x. The translation operator can be expressed in terms of the differential operator as follows by Taylor expansion of f(x) about the point x, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x h)=(1 hD+tfrac12h^2D^2tfrac13h^3D^3+)f(x)=e^ hDf(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comparing the operator expression for the forward translation with the Taylor expansion we obtain, by formal inversion of the operator T, an operator identity for the inverted translation operator T^-1,    ","category":"page"},{"location":"","page":"Home","title":"Home","text":"T(1+Δ)=e^hDT^-1=e^-hD=(1+Δ)^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"With this procedure, the explicit dependence on h can be replaced by an implicit dependence on h through an expansion in powers of Δ ,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x-h)=(1+Δ)^-1f(x)=(1-Δ+Δ^2-Δ^3+)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By choosing the proper expansion order, f(x-h) can be approximated to any desired level of accuracy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"Likewise, for backward differences, we rewrite the backward-difference definition in the form ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x-h)=(1-)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(1-) is the backward translation operator. Comparing this backward translation with the Taylor expansion we obtain, by formal inversion of the operator B, an operator identity for the forward translation operator T, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"B(1-)=e^-hD=T^-1T=e^hD=(1+)^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note how the backward translation operator was identified with the inverse forward translation operator, B=T^-1. When using backward differences, the explicit dependence on h can be replaced by an implicit dependence on h through an expansion in powers of , ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x+h)=(1-)^-1f(x)=(1++^2+^3+)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By choosing the proper expansion order, f(x+h) can be approximated to any desired level of accuracy. ","category":"page"},{"location":"pages/methods/#Finite-difference-methods","page":"Finite-difference methods","title":"Finite-difference methods","text":"","category":"section"},{"location":"pages/methods/#Finite-differences","page":"Finite-difference methods","title":"Finite differences","text":"","category":"section"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Consider the analytical function f tabulated in forward order   (growing index) at n positions on a uniform grid.","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Forward difference notation","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"The forward translation from position n-1 to position n on  the grid is expressed by the relation","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fn = (1 + Δ) fn-1 ","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where Δ is the forward difference operator. By a formal inversion   procedure we find","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where Δ^k is the  k^th-order forward difference defined as a weighted sum over the function values fnn+k (involving k+1 points),","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Δ^k fn = c_k^kfn + c_k-1^kfn+1 +   + fn+k\n= sum_j=0^k c_k-j^k fn+j","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"The k+1 coefficients","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"c_k-j^k=(-1)^k-jbinomkj","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"are the summation weights (short: weights) which define the summation.","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Backward difference notation","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"In backward difference notation, the finite difference of two adjacent values on the grid is defined as","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":" fn = fn-fn-1","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where  is the backward difference operator.  By a formal inversion   procedure we find","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fn+1=(1-)^-1fn=(1++^2+^3+)fn","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where ^k is the  k^th-order backward difference defined as a weighted sum over the function values tabulated in backward order, fn-1n-k (involving k+1 points),","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"^k fn = fn + c_1^kfn-1 +  + c_k^kfn-k\n= sum_j=0^k c_j^kfn-j","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where the k+1 coefficients","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"c_j^k=(-1)^jbinomkj","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"are the summation weights (short: weights) which define the summation. Note the special cases c_0^k1, c_k^k(-1)^k and the symmetry relation","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"c_k-j^k=(-1)^k c_j^k","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Coefficients:  ","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fdiff_weight(k,j)  c_j^k=(-1)^jbinomkj","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"# isforward(notation)\n# isregular(ordering)\nfdiff_weight(k::Int, j::Int)","category":"page"},{"location":"pages/methods/#CamiDiff.fdiff_weight-Tuple{Int64, Int64}","page":"Finite-difference methods","title":"CamiDiff.fdiff_weight","text":"fdiff_weight(k::Int, j::Int)\n\nFinite difference weight coefficient,\n\nc_j^k=(-1)^k+jbinomkj\n\nExample:\n\nc(k,j) = fdiff_weight(k,j)\n\n[[c(k,j) for j=0:k] for k=0:3] == [[1], [1, -1], [1, -2, 1], [1, -3, 3, -1]]\n  true\n\n[[c(k,k-j) for j=0:k] for k=0:3] == [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1]]\n  true\n\n\n\n\n\n","category":"method"},{"location":"pages/methods/#Finite-difference-expansions","page":"Finite-difference methods","title":"Finite difference expansions","text":"","category":"section"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Finite-difference calculus builds on the finite-difference expansion.","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Forward difference notation","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"In terms of forward differences the expansion takes the form","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"sum_p=0^inftyα_pΔ^pfn\n=sum_p=0^kα_pΔ^pfn+","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"A finite-difference expansion truncated at order k is defined by k+1 finite-difference expansion coefficients, represented by the vector α = α_0 α_k. It takes some bookkeeping to rewrite the expansion as a weighted sum over the k+1 function values in forward tabulated form fnn+k. Substituting the finite difference expression for Δ^k, we obtain","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"sum_p=0^kα_pΔ^pfn\n=sum_p=0^kα_psum_j=0^pc_p-j^pfn+j\n=sum_j=0^ksum_p=j^kα_pc_p-j^pfn+j\n=sum_j=0^kF_j^kfn+j","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where the weighted summation is defined by the weights","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"F_j^k=sum_p=j^kα_pc_p-j^p\n=sum_p=j^k(-1)^p+jbinompjα_p","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"with j=0 k. In inner product form the expansion becomes","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"sum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where F^k   F_0^k F_k^k.","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fnn+k = leftbeginarrayc\nfn\nvdots\nfn+k\nendarrayright","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Coefficients:","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fdiff_expansion_weights(polynom, fwd, reg)  F^k  F_0^k F_k^k,","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where polynom is the CamiMath.polynom vector α  α_0 α_k. This polynom has to be supplied by the user to define the expansion under consideration. Some common cases are:","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"interpolation expansion: fdiff_interpolation_expansion_polynom(ξ, k, fwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"differentiation expansion: fdiff_differentiation_expansion_polynom(ξ, k, fwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Adams-Bashford expansion: fdiff_adams_bashford_expansion_polynom(k, fwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Adams-Moulton expansion: fdiff_adams_moulton_expansion_polynom(k, fwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Backward difference notation","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"In terms of backward differences the expansion takes the form","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"sum_p=0^inftyβ_p^pfn=sum_p=0^kβ_p^pfn+","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"In this case the k^th- order finite-difference expansion is defined by the vector β = β_0 β_k. The expansion can written as weighted sum over the k+1 function values in backward tabulated form fn-1n-k. Substituting the finite difference expression for ^k, we obtain","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"sum_p=0^kβ_p^pfn\n=sum_p=0^kβ_psum_j=0^pc_j^pfn-j\n=sum_j=0^ksum_p=j^kβ_pc_j^pfn-j\n=sum_j=0^kB_j^kfn-j","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where the weights are given by","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"B_j^k=sum_p=j^kβ_pc_j^p\n=sum_p=j^k(-1)^jbinompjβ_p","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"with j=0 k. In inner product form the expansion becomes","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"sum_p=0^kβ_p^pfn\n=sum_j=0^k B_j^k fn-j\n=barB^k cdot fn-kn","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where the weights vector barB^k  B_k^k B_0^k contains the weights in backward order.","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"In general there is no simple symmetry relation between B^k and F^k.","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Coefficients:","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fdiff_expansion_weights(polynom, bwd, rev)  barB^k  B_k^k B_0^k,","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"where polynom is the CamiMath.polynom vector  β  β_0 β_k. This polynom has to be supplied by the user to define the expansion under consideration. Some common cases are:","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"interpolation expansion: fdiff_interpolation_expansion_polynom(ξ, k, bwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"differentiation expansion: fdiff_differentiation_expansion_polynom(ξ, k, bwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Adams-Bashford expansion: fdiff_adams_bashford_expansion_polynom(k, bwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"Adams-Moulton expansion: fdiff_adams_moulton_expansion_polynom(k, bwd)","category":"page"},{"location":"pages/methods/","page":"Finite-difference methods","title":"Finite-difference methods","text":"fdiff_expansion_weights(polynom, notation=CamiMath.bwd, ordering=CamiMath.rev)\nfdiff_expansion(polynom, f, notation=CamiMath.bwd)","category":"page"},{"location":"pages/methods/#CamiDiff.fdiff_expansion_weights","page":"Finite-difference methods","title":"CamiDiff.fdiff_expansion_weights","text":"fdiff_expansion_weights(polynom[, notation=bwd[, ordering=rev]])\n\nExpansion weights corresponding to the expansion coefficients CamiMath.polynom of a finite difference expansion.\n\nForward difference notation (notation = fwd)\n\nWeight vector F^k  F_k^k F_0^k corresponding to the expansion coefficients α  α_0^k α_k^k of the k^th-order forward-difference expansion,\n\nsum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytic function f tabulated in forward order.\n\nfdiff_expansion_weights(α, fwd, reg)  F^k  F_0^k F_k^k,\n\nwhere α  α_0 α_k has to be supplied in combination with fwd to indicate that the weights must be evaluated in forward-difference notation.\n\nBackward difference notation (notation = bwd)\n\nWeight vector barB^k  B_k^k B_0^k corresponding to the expansion coefficients β  β_0 β_k of the k^th-order backward-difference expansion,\n\nsum_p=0^kβ_p^pfn\n=sum_j=0^kB_j^kfn-j\n=barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytic function f tabulated in forward order.\n\nfdiff_expansion_weights(β, bwd, rev)  barB^k  B_k^k B_0^k,\n\nwhere β  β_0 β_k has to be supplied in combination with bwd to indicate that the weights must be evaluated in backward-difference notation.\n\nExample:\n\nConsider the expansions,\n\nfn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn\n\nfn+1=(1-)^-1fn=(1++^2+^3+)fn\n\nα = [1,-1,1,-1,1]\nβ = [1,1,1,1,1]\nFk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\n  Fk = [5, -10, 10, -5, 1]\n\nBk = fdiff_expansion_weights(β, bwd, reg); println(\"Bk = $(Bk)\")\n  Bk = [5, -10, 10, -5, 1]\n\nrevFk = fdiff_expansion_weights(α, fwd, rev); println(\"revFk = $(revFk)\")\n  revFk = [1, -5, 10, -10, 5]\n\nrevBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\n  revBk = [1, -5, 10, -10, 5]\n\n\n\n\n\n","category":"function"},{"location":"pages/methods/#CamiDiff.fdiff_expansion","page":"Finite-difference methods","title":"CamiDiff.fdiff_expansion","text":"fdiff_expansion(polynom, f[, notation=bwd])\n\nFinite difference expansion of the analytical function f(x) tabulated in forward order (growing index) at k+1 positions on a uniform grid. The expansion coefficients are specified by the vector CamiMath.polynom. By default CamiMath.polynom are assumed to be in backward-difference notation (bwd). For CamiMath.polynom in forward-difference notation the third argument must be fwd.\n\nForward difference notation (notation = fwd)\n\nsum_p=0^kα_pΔ^pfn = F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytical function f (tabulated in forward order) and α  α_0 α_k is the vector CamiMath.polynom, which has to be supplied to define the forward-difference expansion. The corresponding weights vector F^k is internally generated.\n\nBackward difference notation (notation = bwd)\n\nsum_p=0^kβ_p^pfn = barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytical function f (tabulated in forward order) and β  β_0 β_k is the vector CamiMath.polynom, which has to be supplied to define the backward-difference expansion. The corresponding weights vector barB^k is internally generated.\n\nExamples:\n\nConsider the function f(x)=x^2 and the expansions,\n\nf(x-1)=(1+Δ)^-1=(1-Δ+Δ^2-Δ^3+)f(x)\n\nf(x+1)=(1-)^-1=(1++^2+^3+)f(x)\n\nTo fourth order (k=4) the forward- and backward-difference coefficient vectors are α=[1,-1,1,-1,1] and β=[1,1,1,1,1], respectively. We tabulate the function at k+1 points, f=[1,4,9,16,25].\n\nα = [1,-1,1,-1,1]\nFk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\n  Fk = [5, -10, 10, -5, 1]\n\nβ = [1,1,1,1,1]\nrevBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\n  revBk = [1, -5, 10, -10, 5]\n\nf = [1,4,9,16,25]\no = fdiff_expansion(α, f, fwd); println(\"f[0] = $(o)\")\n  f[0] = 0\n\nfdiff_expansion(α, f, fwd) == Fk ⋅ f == fdiff_interpolation(f, 0)\n  true\n\no = fdiff_expansion(β, f, bwd); println(\"f[6] = $(o)\")\n  f[6] = 36\n\nfdiff_expansion(β, f, bwd) == revBk ⋅ f == fdiff_interpolation(f, length(f)+1)\n  true\n\nIn these cases the results are exact because the function is quadratic and the expansion is third order (based on the polynomial of k^th degree running through the k+1 points of the tabulated function). Note the relation with fdiff_interpolation(f, v, k=3).\n\n\n\n\n\n","category":"function"}]
}
