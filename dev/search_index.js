var documenterSearchIndex = {"docs":
[{"location":"pages/documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"pages/documentation/#Finite-differences","page":"Documentation","title":"Finite differences","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Let fn be the 'function of interest', tabulated in forward order   (growing index) on the grid of natural numbers.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Forward difference notation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The forward translation from position n-1 to position n on  the grid is expressed by the relation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn = (1 + Δ) fn-1 ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where Δ is the forward difference operator. By formal inversion   we find","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where Δ^k is the  k^th-order forward difference defined as a weighted sum over the function values fnn+k (involving k+1 points appearing in regular=forward order),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"beginaligned\nΔ^k fn = fn+k + c_1^kfn+k-1 +   + fn \n         = fn + c_k-1^kfn+1 +   + fn+k = sum_j=0^k c_k-j^k fn+j\nendaligned","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the k+1 coefficients c_k-j^k=(-1)^k c_j^k,  with","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"c_j^k=(-1)^jbinomkj","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"are the summation weights (short: weights) defining the summation, with special values  c_0^k1 and c_k^k(-1)^k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In inner product form the result becomes","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Δ^k fn=barc^k cdot fnn+k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where barc^k   c_k^k c_0^k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Backward difference notation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The backward translation from position n to position n-1 on  the grid is expressed by the relation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn = (1 - ) fn+1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where  is the backward difference operator.  By formal inversion   we obtain in this case","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn+1=(1-)^-1fn=(1++^2+^3+)fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where ^k is the  k^th-order backward difference defined as a weighted sum over the function values fn-1n-k (involving  k+1 points appearing in reversed order),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"^k fn = fn + c_1^kfn-1 +  + fn-k\n= sum_j=0^k c_j^kfn-j","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the k+1 coefficients c_j^k are the summation weights  (short: weights) defining the summation. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In inner product form the result becomes","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"^k fn = c^k cdot fn-1n-k =barc^k cdot fn-kn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where c^k   c_0^k c_k^k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Coefficients:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fdiff_weight(k, j)  c^k  c_0^k c_k^k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"# isforward(notation)\n# isregular(ordering)\nfdiff_weight(k::Int, j::Int)","category":"page"},{"location":"pages/documentation/#CamiDiff.fdiff_weight-Tuple{Int64, Int64}","page":"Documentation","title":"CamiDiff.fdiff_weight","text":"fdiff_weight(k::Int, j::Int)\n\nFinite difference weight coefficient,\n\nc_j^k=(-1)^jbinomkj\n\nExample:\n\njulia> c(k,j) = fdiff_weight(k,j);\n\njulia> a = [[c(k,j) for j=0:k] for k=0:3]\n4-element Vector{Vector{Int64}}:\n [1]\n [1, -1]\n [1, -2, 1]\n [1, -3, 3, -1]\n\njulia> b = [[c(k,k-j) for j=0:k] for k=0:3]\n4-element Vector{Vector{Int64}}:\n [1]\n [-1, 1]\n [1, -2, 1]\n [-1, 3, -3, 1]\n\njulia> b == reverse.(a)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#Finite-difference-expansions","page":"Documentation","title":"Finite difference expansions","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Finite-difference calculus builds on finite-difference expansions on a uniform grid.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Forward difference notation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In terms of forward differences the generic form of the finite-difference expansion is given by","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^inftyα_pΔ^pfn\n=sum_p=0^kα_pΔ^pfn+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Evaluated to order k, the expansion is defined by k+1 finite-difference expansion coefficients,  supplied by the user in the form of the expansion vector, α = α_0 α_k. This vector contains the coefficients in the regular ordering of growing index. It takes some bookkeeping to rewrite the expansion  as a weighted sum over the k+1 function values fnn+k (note the regular ordering of growing grid position). After substituting the forward difference, Δ = fn+1 - fn,  the finite-difference expansion takes the form","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kα_pΔ^pfn\n=sum_p=0^kα_psum_j=0^pc_p-j^pfn+j\n=sum_j=0^ksum_p=j^kα_pc_p-j^pfn+j\n=sum_j=0^kF_j^kfn+j","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the weighted summation is defined by the weights","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"F_j^k=sum_p=j^kα_pc_p-j^p\n=sum_p=j^k(-1)^p+jbinompjα_p","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"with j=0 k. In inner product form, the expansion becomes","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where F^k   F_0^k F_k^k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Summary:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In CamiDiff, any finite-difference expansion is defined by a (user-supplied) polynom  (the vector of expansion coefficients). In fwd-difference notation we write","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"polynom  α  α_0 α_k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Examples are given below. Once we have the coefficients (in the form of the polynom),  we can calculate the weights (the fwd-difference weights vector) in reg-fwd-notation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"weights = fdiff_expansion_weights(polynom, fwd, reg)  F^k  F^k_0 F^k_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"and the result of the expansion is obtained by evaluating the following inner product (in fwd-difference notation)  ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kα_pΔ^pfn = F^k cdot fnn+k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Examples:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The polynoms of four common expansions in fwd-difference notation are:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"interpolation: fdiff_interpolation_expansion_polynom(σ, k, fwd)  α  α_0(σ) α_k(σ)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"differentiation: fdiff_differentiation_expansion_polynom(σ, k, fwd)  α  α_0(σ) α_k(σ)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Adams-Bashford: fdiff_adams_bashford_expansion_polynom(k, fwd)  α  α_0 α_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Adams-Moulton: fdiff_adams_moulton_expansion_polynom(k, fwd)  α  α_0 α_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Backward difference notation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In terms of backward differences the generic form of the finite-difference expansion is given by","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^inftyβ_p^pfn=sum_p=0^kβ_p^pfn+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In this case the k^th- order finite-difference expansion is defined by the (user-supplied) expansion vector β = β_0 β_k, containing the expansion coefficients  in regular ordering (growing index). The expansion can written as  a weighted sum over the k+1 function values fn-1n-k (note reversed ordering  of decreasing grid position). Substituting the definition of the backward difference,  = fn - fn-1,  the finite-difference expression takes the form","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kβ_p^pfn\n=sum_p=0^kβ_psum_j=0^pc_j^pfn-j\n=sum_j=0^ksum_p=j^kβ_pc_j^pfn-j\n=sum_j=0^kB_j^kfn-j","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the weights are given by","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"B_j^k=sum_p=j^kβ_pc_j^p\n=sum_p=j^k(-1)^jbinompjβ_p","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"with j=0 k. In inner product form, the expansion becomes","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kβ_p^pfn\n=sum_j=0^k B_j^k fn-j\n=barB^k cdot fn-kn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where barB^k  B_k^k B_0^k is the weights vector B^k  B_0^k B_k^k tabulated  in reversed order.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The relation between B^k and F^k depends on the relation between the expansion polynoms α and β, which is not unique (it depends on the expansion under consideration).","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Summary:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In CamiDiff, any finite-difference expansion is defined by a (user-supplied) polynom  (the vector of expansion coefficients). In bwd-difference notation we write","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"polynom  β  β_0 β_k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Examples are given below. Once we have the coefficients (in the form of polynom) we can calculate the weights (the bwd-difference weights vector) in rev-bwd-notation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"weights = fdiff_expansion_weights(polynom, bwd, rev)  barB^k(σ)  B_k^k(σ) B_0^k(σ),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"and the result of the expansion is obtained by evaluating the following inner product (in bwd-difference notation),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kβ_p^pfn = barB^k(σ) cdot fn-kn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Examples:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The polynoms of four common expansions in bwd-difference notation are:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"interpolation: fdiff_interpolation_expansion_polynom(σ, k, bwd)  β(σ)  β_0(σ) β_k(σ)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"differentiation: fdiff_differentiation_expansion_polynom(σ, k, bwd)  β(σ)  β_0(σ) β_k(σ)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Adams-Bashford: fdiff_adams_bashford_expansion_polynom(k, bwd)  β(σ)  β_0 β_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Adams-Moulton: fdiff_adams_moulton_expansion_polynom(k, bwd) β(σ)  β_0 β_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"# fdiff_expansion(polynom, f, notation=bwd)\nfdiff_expansion_weights(polynom, notation=CamiMath.bwd, ordering=CamiMath.rev)","category":"page"},{"location":"pages/documentation/#CamiDiff.fdiff_expansion_weights","page":"Documentation","title":"CamiDiff.fdiff_expansion_weights","text":"fdiff_expansion_weights(polynom [, notation=bwd [, ordering=rev]])\n\nWeights vector corresponding to the expansion coefficient vector polynom of a (user-defined) finite-difference expansion.\n\nForward-difference notation (notation = fwd)\n\nThe weights vector F^k  F_k^k F_0^k corresponds to the expansion coefficient  vector α  α_0 α_k of the k^th-order forward-difference expansion (polynom = α).\n\nsum_p=0^kα_pΔ^pfn\n=sum_j=0^kF_j^kfn+j\n=F^k cdot fnn+k\n\nwhere fnn+k are elements of the analytic function f tabulated in regular=forward order.\n\nfdiff_expansion_weights(α, fwd, reg)  F^k  F_0^k F_k^k,\n\nwhere α  α_0 α_k has to be supplied by the user in combination with fwd to indicate that the weights must be evaluated in forward-difference notation.\n\nBackward difference notation (notation = bwd)\n\nThe weights vector barB^k  B_k^k B_0^k corresponds to the expansion coefficient  vector β  β_0 β_k of the k^th-order backward-difference expansion (polynom = β).\n\nsum_p=0^kβ_p^pfn\n=sum_j=0^kB_j^kfn-j\n=barB^k cdot fn-kn\n\nwhere fn-kn are elements of the analytic function f tabulated in forward order.\n\nfdiff_expansion_weights(β, bwd, rev)  barB^k  B_k^k B_0^k,\n\nwhere β  β_0 β_k has to be supplied by the user in combination with bwd to indicate that the weights must be evaluated in backward-difference notation.\n\nExample:\n\nConsider the expansions,\n\nbeginaligned\nfn-1=(1+Δ)^-1fn=(1-Δ+Δ^2-Δ^3+)fn=F^k cdot fnn+k\nfn+1=(1-)^-1fn=(1++^2+^3+)fn=barB^k cdot fn-kn\nendaligned\n\njulia> f = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100];\n\njulia> α = [1,-1,1,-1,1];\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [5, -10, 10, -5, 1]\n\njulia> β = [1,1,1,1,1];\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = [1, -5, 10, -10, 5]\n\njulia> sum(Fk .* f[7:11]) # inner product\n25\n\njulia> sum(revBk .* f[1:5]) # inner product\n25\n\njulia> f[6]\n25\n\n\n\n\n\n","category":"function"},{"location":"pages/documentation/#Lagrange-interpolation","page":"Documentation","title":"Lagrange interpolation","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The Lagrange polynomial of degree k on a uniform grid is the polynomial running  through k+1 subsequent points on the grid. We derive expressions for  interpolation in both forward- and backward-difference notation. Beware  that Lagrange interpolation becomes inaccurate if the tabulated function cannot be  approximated by a polynomial of degree k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Forward difference notation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Starting from the forward translation expression","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn=(1+Δ)fn-1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"we obtain by formal operator inversion","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn-1 = (1 + Δ)^-1 fn  sum_p=0^infty(-1)^p Δ^p fn+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn-2 = (1 + Δ)^-2 fn  sum_p=0^infty(-1)^p pΔ^p fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"vdots","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where p is called the order of the expansion and n is the index of the reference position. For interpolation position v=n-σ (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn-σ = (1 + Δ)^-σ fn  sum_p=0^infty (-1)^p l_p(σ) Δ^p fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where α_p(σ) = (-1)^p l_p(σ) is the p^th-order finite-difference expansion coefficient for lagrangian interpolation. Here we define ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"l_p(σ)  (σ)_pp","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"with","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"(σ)_p=begincases\n1  p=0\nσ(σ+1)(σ+2)cdots(σ+p-1)  p0\nendcases","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"being the Pochhammer symbol CamiMath.pochhammer. Note that for σ = 1 we find  α_p  α_p(1)  (-1)^p, which are the coefficients for the 'next-point' expansion. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"For -k  σ  0 the method can be used for interpolation over the grid position interval  n  v  n+k. Outside this interval, in particular for σ  0, the method amounts to  extrapolation. The method is most accurate for -1  σ  1 (corresponding to the grid  position interval n-1  v  n+1). Extrapolation to values v  n+k is not recommended. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"NB. The forward offset is defined as σ  n-v.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Summary:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In CamiDiff, the polynom of the fwd-interpolation expansion is calculated with","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"polynom = fdiff_interpolation_expansion_polynom(σ, k, fwd)  α(σ)  α_0(σ) α_k(σ), where α_p(σ) = (-1)^p l_p(σ).","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Once we have the coefficients (in the form of polynom) we can calculate the weights  (the fwd-interpolation expansion weights vector) in reg-fwd-notation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"weights = fdiff_expansion_weights(polynom, fwd, reg)  F^k(σ)  F_0^k(σ) F_k^k(σ),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"and the interpolated value at grid position n-σ evaluates (in fwd-difference notation) to","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn-σ = F^k(σ) cdot fnn+k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Backward difference notation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Starting from the relation","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn=(1-)fn+1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"we obtain by formal operator inversion","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn+1 = (1 - )^-1 fn  sum_p=0^infty^p fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn+2 = (1 - )^-2 fn  sum_p=0^inftyp^p fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"vdots","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where k is called the order of the expansion and n is the reference index. For interpolation position v=σ-n (where σ may be real valued in index units) these expansions can be generalized to the form of lagrangian interpolation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn+σ = (1 - )^-σ fn  sum_p=0^infty l_p(σ) ^p fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where β_p(σ) = l_p(σ) is the p^th-order finite-difference expansion coefficient  for lagrangian interpolation, with (σ)_p being the Pochhammer symbol CamiMath.pochhammer.   Note that for σ = 1 we find β_p  β_p(1)  1, which are the coefficients for the  'next-point' expansion. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"For -k  σ  0 the method can be used for interpolation over the grid position interval  n-k  v  n, outside this interval, in particular for σ  0, the method amounts to  extrapolation. The method is most accurate for -1  σ  1 (corresponding to the grid  position interval n-1  v  n+1). Extrapolation to values v  n-k is not recommended. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"NB. The backward offset is defined as σ  -(n-v).","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Summary:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In CamiDiff, the polynom of the bwd-interpolation expansion is calculated with","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"polynom = fdiff_interpolation_expansion_polynom(σ, k, bwd)  β(σ)  β_0(σ) β_k(σ), where β_p(σ) = l_p(σ).","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Once we have the coefficients (in the form of polynom) we can calculate the weights (the bwd-interpolation expansion weights vector) in rev-bwd-notation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"weights = fdiff_expansion_weights(polynom, bwd, rev)  barB^k(σ)  B_k^k(σ) B_0^k(σ),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"and the interpolated value at grid position n+σ evaluates  (in bwd-difference notation) to","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn+σ = barB^k(σ) cdot fn-kn","category":"page"},{"location":"pages/documentation/#Example-1:","page":"Documentation","title":"Example 1:","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Demonstration of forward-difference extrapolation to 'next point' (grid position 'v=n-1')","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"julia> n=5; v=4; k=5;\n\njulia> σ = n-v # fwd offset to 'next point'\n1\n\njulia> α = fdiff_interpolation_expansion_polynom(σ, k, fwd); println(\"α = $α\")\nα = [1, -1, 1, -1, 1, -1]\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [6, -15, 20, -15, 6, -1]\n\njulia> f = [v^2 for v=1:10]; println(\"f = $f\")\nf = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\njulia> Fk ⋅ f[n:n+k] == f[n-1] == v^2\ntrue","category":"page"},{"location":"pages/documentation/#Example-2:","page":"Documentation","title":"Example 2:","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Demonstration of backward-difference interpolation to grid position 'v=6.25`","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"julia> n=9; v=6.25; k=5;\n\njulia> σ = -(n-v) # bwd-offset of interpolation position\n-1.25\n\njulia> β = fdiff_interpolation_expansion_polynom(σ, k, bwd); println(\"β = $β\")\nβ = [1.0, -2.75, 2.40625, -0.6015625, -0.03759765625, -0.0093994140625]\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = [0.0093994140625, -0.0845947265625, 0.845947265625, 0.281982421875, -0.0604248046875, 0.0076904296875]\n\njulia> f = [v^2 for v=1:10]; println(\"f = $f\")\nf = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\njulia> revBk ⋅ f[n-k:n] ≈ v^2\ntrue","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fdiff_interpolation_expansion_polynom(σ::T, k=3, notation=bwd) where T<:Real\n# fdiff_interpolation_expansion_weights(σ::T, notation=bwd, ordering=rev; k=3) where T<:Real\n# fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T<:Real, V<:Real}","category":"page"},{"location":"pages/documentation/#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Documentation","title":"CamiDiff.fdiff_interpolation_expansion_polynom","text":"fdiff_interpolation_expansion_polynom(σ::T [, k=3 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining the k^th-order (default third order) Lagrange-polynomial interpolation of a tabulated analytic function fn at offset σ with respect to index position n, which is positive for increasing index and negative for decreasing index.\n\nForward difference notation (notation = fwd)\n\nIn this case we consider the tabulated interval fnn+k. The interpolated value fn-σ is given by the forward-difference expansion\n\nfn-σ = sum_p=0^k α_p(σ) Δ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(σ, k, fwd)  α(σ)  α_0(σ) α_k(σ). \n\nApplication: This polynom can serve to predict f[n-1] by extrapolation (using σ=1)  if f[n:n+k] are known. More generally, it can serve to interpolate to (real) positions  n  v  n+k (using -k  σ  0) and predict f[n-σ] by extrapolation to (real)  positions vn (using σ  0) or vn+k (using σ  -k).  \n\nNB. The forward offset is defined as σ  n-v.\n\nBackward difference notation (notation = bwd)\n\nIn this case we consider the tabulated interval fn-kn. The interpolated value fn+σ is given by the backward-difference expansion\n\nfn+σ = sum_p=0^k β_p(σ) ^p fn + \n\nwhere the expansion coefficients are given by\n\nfdiff_interpolation_expansion_polynom(σ, k, bwd)  β(σ)  β_0(σ) β_k(σ). \n\nApplication: This polynom can serve to predict f[n+1] by extrapolation (using σ=1)  if f[n-k:n] are known. More generally, it can serve to interpolate to (real) positions  n-k  v  n (using -k  σ  0) and predict f[n+σ] by extrapolation to (real)  positions xvn (using σ  0) or vn+k (using σ  -k). \n\nNB. The backward offset is defined as σ  -(n-v).\n\nExample:\n\njulia> σ = 1; # offset correponding to extrapolation\n\njulia> α = fdiff_interpolation_expansion_polynom(σ, k, fwd); println(\"α = $α\")\nα = [1, -1, 1, -1, 1, -1]\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [6, -15, 20, -15, 6, -1]\n\njulia> β = fdiff_interpolation_expansion_polynom(σ, k, bwd); println(\"β = $β\")\nβ = [1, 1, 1, 1, 1, 1]\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = [-1, 6, -15, 20, -15, 6]\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#Lagrangian-differentiation","page":"Documentation","title":"Lagrangian differentiation","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Forward difference notation (notation = fwd)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"To derive the lagrangian differentiation formulas we formally differentiate","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn-σ = (1+Δ)^-σ fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"with respect to -σ,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"-fracdfdσn-σ\n=ln(1+Δ) (1+Δ)^-σfn\n=sum_q=1^k(-1)^qtfrac1qΔ^qsum_p=0^k(-1)^p l_p(σ)Δ^pfn+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where l_p(σ)  (σ)_pp, with (σ)_p being the Pochhammer symbol CamiMath.pochhammer.   Rewriting the r.h.s. as a single expansion in powers of Δ, we obtain to order k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"-fracdfdσn-σ=sum_p=1^kα_p(σ)Δ^pfn=F^k(σ)  fnn+k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where α_p(σ) represents the finite-difference expansion coefficients for lagrangian differentiation at position n-σ. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In the general case (σ  0), the coefficients α_p(σ) are obtained numerically  by polynomial multiplication using the function CamiMath.polynom_product(p_a, p_b), where","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"beginaligned\np_a = 0 -1 12  (-1)^k 1k \np_b = l_0(σ) -l_1(σ)  (-1)^k l_k(σ)\nendaligned","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Special case:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In the special case σ = 0, we have p_b =  1 0  0 and the fwd-difference  coefficient vector for lagrangian differentiation at position n reduces to","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"α^k = α^k(0) = p_a = 0 -1 12  (-1)^k 1k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Summary:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In CamiDiff, the polynom of the forward-differentiation expansion is calculated by","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"polynom = fdiff_differentiation_expansion_polynom(σ, k, fwd)  α(σ)  α_0(σ) α_k(σ),  with α_0(σ) 0.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Once we have the coefficients (in the form of polynom) we can calculate the weights  (the fwd-differentiation weights vector) in reg-fwd-notation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"weights = fdiff_expansion_weights(polynom, fwd, reg)  F^k(σ)  F^k_0(σ) F^k_k(σ),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"and the derivative at grid position n-σ in fwd-difference notation evaluates to","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"-fracdfdσn-σ\n=sum_j=0^kF_j^k(σ)fn+j\n= F^k(σ)  fnn+k","category":"page"},{"location":"pages/documentation/#Example:","page":"Documentation","title":"Example:","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"First derivative of the tabulated function fnn+k at the position v = 65 (zero-offset)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"n=5; v=6.5; k=5;\n\njulia> σ = n-v # forward offset at grid position ``v``.\n-1.5\n\njulia> α = fdiff_differentiation_expansion_polynom(σ, k, fwd); println(\"α = $α\")\nα = [0.0, 1.0, 1.0, -0.041666666666666685, 0.0, 0.004687500000000011]\n\njulia> Fk = fdiff_expansion_weights(α, fwd, reg); println(\"Fk = $(Fk)\")\nFk = [0.036979166666666674, -1.1015625, 1.078125, 0.005208333333333426, -0.023437500000000056, 0.004687500000000011]\n\njulia> f = [v^2 for v=1:10]; println(\"f = $f\")\nf = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\njulia> Fk ⋅ f[n:n+k] ≈ 2v\ntrue\n\njulia> f = [v^3 for v=1:10]; println(\"f = $f\")\nf = [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n\njulia> Fk ⋅ f[n:n+k] ≈ 3v^2\ntrue","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"backward difference notation (notation = bwd)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"To derive the lagrangian differentiation formulas we formally differentiate","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fn+σ = (1 - )^-σ fn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"with respect to σ,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fracdfdσn+σ\n=-ln(1-) (1-)^-σfn\n=sum_q=1^ktfrac1q^qsum_p=0^kl_p(σ)^pfn+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where l_p(σ)  (σ)_pp, with (σ)_p being the Pochhammer symbol CamiMath.pochhammer. Rewriting the r.h.s. as a single expansion in powers of , we obtain to order k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fracdfdσn+σ=sum_p=1^kβ_p(σ)^pfn=barB^k(σ)  fn-kn","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where β_p(σ) represents the finite-difference expansion coefficients for lagrangian differentiation at position n+σ. ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In the general case (σ  0), the coefficients β_p(σ)  are obtained numerically by polynomial multiplication using the function CamiMath.polynom_product(p_a, p_b), where ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"beginaligned\np_a = 0 1 12  1k\np_b = l_0(σ) l_1(σ)  l_k(σ)\nendaligned","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Special case:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In the special case σ = 0, we have p_b =  1 0  0 and the bwd-difference  coefficient vector for lagrangian differentiation at position n reduces to","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"β^k = β^k(0) = p_a = 0 1 12   1k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Summary:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"In CamiDiff, the polynom of the backward-differentiation expansion is calculated by","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"polynom = fdiff_differentiation_expansion_polynom(σ, k, fwd)  β(σ)  β_0(σ) β_k(σ),  with β_0(σ) 0.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Once we have the coefficients (in the form of polynom) we can calculate the weights  (the bwd-differentiation weights vector) in rev-bwd-notation,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"barB^k(σ) = fdiff_expansion_weights(polynom, bwd, rev)  barB^k(σ)  B_k^k(σ) B_0^k(σ),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"and the derivative at grid position n+σ in bwd-difference notation evaluates to ","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fracdfdσn+σ=barB^k(σ)  fn-kn","category":"page"},{"location":"pages/documentation/#Example:-2","page":"Documentation","title":"Example:","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"First derivative of the tabulated function fn-kn at the position v = n (zero-offset)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"julia> n=9; v=9; k=5;\n\njulia> σ = -(n-v) # backward offset at grid position ``v``.\n0\n\njulia> β = fdiff_differentiation_expansion_polynom(σ, k, bwd); println(\"β = $β\")\nβ = Rational{Int64}[0, 1, 1//2, 1//3, 1//4, 1//5]\n\njulia> revBk = fdiff_expansion_weights(β, bwd, rev); println(\"revBk = $(revBk)\")\nrevBk = Rational{Int64}[-1//5, 5//4, -10//3, 5, -5, 137//60]\n\njulia> f = [v^2 for v=1:10]; println(\"f = $f\")\nf = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\njulia> revBk ⋅ f[n-k:n] ≈ 2v\ntrue","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fdiff_differentiation_expansion_polynom(σ::T, k=5, notation=bwd) where T<:Real\ncreate_lagrange_differentiation_matrix(k::Int)","category":"page"},{"location":"pages/documentation/#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T<:Real","page":"Documentation","title":"CamiDiff.fdiff_differentiation_expansion_polynom","text":"fdiff_differentiation_expansion_polynom(σ::T [, k=5 [, notation=bwd]]) where T<:Real\n\nFinite-difference expansion coefficient vector defining k^th-order lagrangian differentiation of the tabulated analytic function fn at position  v=n-σ.\n\nForward difference notation (notation = fwd)\n\nfracdfdσn+σ=sum_p=0^kα_p(σ)Δ^pfn\n\nOffset convention: σ = n-v with respect to index n in tabulated interval fnn+k\n\nBackward difference notation (notation = bwd)\n\nfracdfdσn+σ=sum_p=0^kβ_p(σ)^pfn\n\nwhere β(σ)  β_0(σ)  β_p(σ)\n\nOffset convention: σ = -(n-v) with respect to index n in tabulated interval fn-kn\n\nExample:\n\njulia> k = 5; σ = 0; # offset correponding to differentiation\n\njulia> o = fdiff_differentiation_expansion_polynom(0, k, fwd); println(o)\nRational{Int64}[0, 1, -1//2, 1//3, -1//4, 1//5]\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}","page":"Documentation","title":"CamiDiff.create_lagrange_differentiation_matrix","text":"create_lagrange_differentiation_matrix(k::Int)\n\nLagrange differentiation matrix, mij=s_k-j^k(i), for k^th-order lagrangian differentiation,\n\nfracdydxi= sum_j=0^kmijyj\n\nExample:\n\nk = 3\ncreate_lagrange_differentiation_matrix(k)\n 4×4 Matrix{Rational{Int64}}:\n  -11//6   3//1  -3//2   1//3\n   -1//3  -1//2   1//1  -1//6\n    1//6  -1//1   1//2   1//3\n   -1//3   3//2  -3//1  11//6\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#Integration","page":"Documentation","title":"Integration","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"trapezoidal_epw(k::Int; rationalize=false, devisor=false)\ntrapezoidal_integration(f, x1, x2, weights)","category":"page"},{"location":"pages/documentation/#CamiDiff.trapezoidal_epw-Tuple{Int64}","page":"Documentation","title":"CamiDiff.trapezoidal_epw","text":"trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])\n\nEndpoint weights vector a=a_1 a_k of trapeziodal rule optimized for functions of polynomial form,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nwhere k is odd. The rule is exact for polynonials of degree d=0 1  k-1. For k=1 the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\n[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]\n5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n  (1, 2, [1])\n  (3, 24, [9, 28, 23])\n  (5, 1440, [475, 1902, 1104, 1586, 1413])\n  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])\n  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,\n                                                     5095890, 7783754, 7200319])\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#CamiDiff.trapezoidal_integration-NTuple{4, Any}","page":"Documentation","title":"CamiDiff.trapezoidal_integration","text":"trapezoidal_integration(f, x1, x2, weights)\n\nIntegral of the tabulated function f=f_0 f_n over the domain x1  x  x2 using the optimized trapezoidal rule with endpoint correction by the weights vector weights,\n\n    _0^n f(x) dx = a_1 (f_0+f_n) +  + a_k (f_k-1+f_n-k+1)\n                                                         + (f_k++f_n-k)\n\nThe rule is exact for polynonials of degree d=0 1 k-1. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples::\n\np = 3\nc = [1 for i=0:p]\npol = ImmutablePolynomial(c,:z)\nIpol = integrate(pol)\nn = 10\n\nx1=0.0\nx2=5.0\nx = collect(range(x1, x2, n))\nf = pol.(x .-2.5)\n\nw3 = trapezoidal_epw(3)\ntrapezoidal_integration(f, x1, x2, w3)\n 15.416666666666673\n\nIpol(2.5)-Ipol(-2.5)\n 15.41666666666666\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#Adams-Method","page":"Documentation","title":"Adams Method","text":"","category":"section"},{"location":"pages/documentation/#Adams-Bashford-expansion","page":"Documentation","title":"Adams-Bashford expansion","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The Adams-Bashford integration step is given by the expansion","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"yn+1-yn = -frach (1-)ln(1-)fn+1=h (sum_p=0^inftyB_p^p)fn+1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"A closed expression for the Adams-Bashford expansion coefficients, B_k, is not available. As we already have a finite-difference expansion for the operator (1-)^-1,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"frac11-sum_p=0^infty^p","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"we ask for the expansion of","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"-fracln(1-)\n=(1-frac12-frac124^2-frac112^3+)fn+1\n= (sum_p=0^inftyb_p^p)fn+1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"This is known as the Adams-Moulton expansion. Its expansion coefficients are calculated numerically by the function fdiff_adams_moulton_expansion_polynom(k). The Adams-Bashford expansion is obtained as the polynomial product of the two expansions,","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"(sum_p=0^inftyB_p^p)fn+1\n=(sum_p=0^infty^p)(sum_p=0^inftyb_p^p)fn+1\n= ( 1 + frac12 + frac512^2 + )fn+1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the vector β = B_0 B_k contains the Adams-Bashford expansion coefficients, rational numbers generated numerically by the function fdiff_adams_bashford_expansion_polynom(k). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kB_p^pfn\n=sum_p=0^kB_psum_j=0^p c_j^ifn-j\n= sum_j=0^kA_j^kfn-j\n= sum_j=0^kA_k-j^kfn-k+j","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the A_j^k= sum_p=j^k B_pc_j^p are the (k+1)-point Adams-Bashford integration weights.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Function:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"β = fdiff_adams_bashford_expansion_polynom(k)  B_0 B_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"adams_bashford_weights = fdiff_expansion_weights(β, bwd, rev)   A_k^k A_0^k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"adams_bashford_weights = create_adams_bashford_weights(k)  A_k^k A_0^k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fdiff_adams_bashford_expansion_polynom(k::Int; T=Int, msg=true)\ncreate_adams_bashford_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"pages/documentation/#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}","page":"Documentation","title":"CamiDiff.fdiff_adams_bashford_expansion_polynom","text":"fdiff_adams_bashford_expansion_coeff(k::Int [; T=Int [, msg=true]])\nfdiff_adams_bashford_expansion_polynom(k::Int [; T=Int [, msg=true]])\n\n(k+1)-point Adams-Bashford expansion coefficients B_k equiv B_0^k B_k^k.  Note the forward vector ordering, which is the order of use in the summation below,\n\n-frac(1-)ln(1-)=sum_p=0^inftyB_p^p=1+ frac12+ frac512^2+ \n\nExamples:\n\njulia> o = fdiff_adams_bashford_expansion_polynom(5); println(o)\nRational{Int64}[1, 1//2, 5//12, 3//8, 251//720, 95//288]\n\njulia> fdiff_adams_bashford_expansion_coeff(0)\n1//1\n\njulia> fdiff_adams_bashford_expansion_coeff(5)\n95//288\n\njulia> fdiff_adams_bashford_expansion_coeff(20)\nInteger-overflow protection: output converted to BigInt\n8136836498467582599787//33720021833328230400000\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#CamiDiff.create_adams_bashford_weights-Tuple{Int64}","page":"Documentation","title":"CamiDiff.create_adams_bashford_weights","text":"create_adams_bashford_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Bashford weights vector b^k equivb_k^k b_0^k.  Note the reversed order, which corresponds to the order of use in the summation below,\n\nyn+1 = yn + frac1Dsum_j=0^kb^kjfn+1-k+j\n\nwhere b^kj equiv b_k-j^k. The b_j^k are the Adams-Bashford weight coefficients, with D the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.\n\nExample:\n\njulia> [create_adams_bashford_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [-1, 3])\n (2, 12, [5, -16, 23])\n (3, 24, [-9, 37, -59, 55])\n (4, 720, [251, -1274, 2616, -2774, 1901])\n (5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])\n\njulia> k = 5;\n\njulia> w = create_adams_bashford_weights(k; rationalize=true, devisor=true); println(w)\n(5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])\n\njulia> w = create_adams_bashford_weights(k; rationalize=true, devisor=false); println(w)\nRational{Int64}[-95//288, 959//480, -3649//720, 4991//720, -2641//480, 4277//1440]\n\njulia> w = create_adams_bashford_weights(k; rationalize=false); println(w)\n[-0.3298611111111111, 1.9979166666666666, -5.0680555555555555, 6.9319444444444445, -5.502083333333333, 2.970138888888889]\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#Adams-Moulton-expansion","page":"Documentation","title":"Adams-Moulton expansion","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The Adams-Moulton integration step is given by the expansion","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"yn+1-yn\n= -fracln(1-)fn+1\n= ( 1 - frac12 - frac112^2 - frac124^3 +)fn+1","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"For the evaluation of the integration step we limit the summation to k+1 terms (order k),","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"yn+1-yn= (sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the vector β = b_0 b_k contains the Adams-Moulton expansion coefficients, rational numbers generated numerically by the function fdiff_adams_moulton_expansion_polynom(k). Extracting the greatest common denominator, 1D, the step becomes","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"yn+1-yn= frac1D(sum_p=0^kb_p^p)fn+1+","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where b_0 b_k are integers and b_p=b_pD. In practice the expansion is restricted to k18 (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to k = 10). Evaluating the finite-difference expansion up to order k we obtain (after changing dummy index bring the summation in forward order)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"sum_p=0^kb_p^pfn\n=sum_p=0^kb_psum_j=0^p c_j^ifn-j\n= sum_j=0^ka_j^kfn-j\n= sum_j=0^ka_k-j^kfn-k+j","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"where the a_j^k= sum_p=j^k b_pc_j^p are the (k+1)-point Adams-Moulton integration weights.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"Functions:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"β = fdiff_adams_moulton_expansion_polynom(k)  b_0 b_k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"adams_moulton_weights = fdiff_expansion_weights(β, bwd, rev)  a_k^k a_0^k.","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"adams_moulton_weights = create_adams_moulton_weights(k)  a_k^k a_0^k","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"fdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)\ncreate_adams_moulton_weights(k::Int; rationalize=false, devisor=false, T=Int)","category":"page"},{"location":"pages/documentation/#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}","page":"Documentation","title":"CamiDiff.fdiff_adams_moulton_expansion_polynom","text":"fdiff_adams_moulton_expansion_coeff(k::Int; T=Int, msg=true)\nfdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)\n\nFinite difference expansion coefficient vector β  β_0(x)  β_k(x). Note the forward vector ordering, which is the order of use in the summation below,\n\n-fracln(1-)\n= sum_p=0^inftyβ_p^p\n= 1 - frac12 - frac112^2 - frac124^3 +\n\nExamples:\n\njulia> k = 5;\njulia> β = fdiff_adams_moulton_expansion_polynom(k); println(β)\nRational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]\n\njulia> fdiff_adams_moulton_expansion_coeff(k)\n-3//160\n\njulia> D = denominator(gcd(β))\n1440\n\njulia> convert(Vector{Int},(β .* D)); println(o)\n[1440, -720, -120, -60, -38, -27]\n\njulia> k = 20;\njulia> fdiff_adams_moulton_expansion_coeff(k)\nInteger-overflow protection: output converted to BigInt\n-12365722323469980029//4817145976189747200000\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#CamiDiff.create_adams_moulton_weights-Tuple{Int64}","page":"Documentation","title":"CamiDiff.create_adams_moulton_weights","text":"create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])\n\nk^th-order Adams-Moulton weights vector a^k equiva_k^k a_0^k.   Note the reversed vector ordering, which is the order of use in the summation below,\n\nyn+1 = yn + frac1Dsum_j=0^ka^kjfn+1-k+j\n\nwhere a^kj equiv a_k-j^k. The a_j^k are the Adams-Moulton weight coefficients and D is the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.\n\nExample:\n\njulia> [create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]\n8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:\n (1, 2, [1, 1])\n (2, 12, [-1, 8, 5])\n (3, 24, [1, -5, 19, 9])\n (4, 720, [-19, 106, -264, 646, 251])\n (5, 1440, [27, -173, 482, -798, 1427, 475])\n\njulia> k = 5;\njulia> w = create_adams_moulton_weights(k; rationalize=true, devisor=true); println(w)\n(5, 1440, [27, -173, 482, -798, 1427, 475])\n\njulia> w = create_adams_moulton_weights(k; rationalize=true, devisor=false); println(w)\nRational{Int64}[3//160, -173//1440, 241//720, -133//240, 1427//1440, 95//288]\n\njulia> w = create_adams_moulton_weights(k; rationalize=false); println(w)\n[0.01875, -0.12013888888888889, 0.3347222222222222, -0.5541666666666667, 0.9909722222222223, 0.3298611111111111]\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#Application","page":"Documentation","title":"Application","text":"","category":"section"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"The three elementary operations are:","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"grid_interpolation(f, rval, grid)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"grid_differentiation(f, grid)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"grid_integration(f, grid)","category":"page"},{"location":"pages/documentation/","page":"Documentation","title":"Documentation","text":"grid_interpolation(f::Vector{T}, grid::Grid{T}, rv::T, notation=fwd; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}) where T<:Real","category":"page"},{"location":"pages/documentation/#CamiDiff.grid_interpolation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}, T}, Tuple{Vector{T}, Grid{T}, T, Any}} where T<:Real","page":"Documentation","title":"CamiDiff.grid_interpolation","text":"grid_interpolation(f::Vector{T}, grid::Grid{T}, rv::T, notation=fwd; k=5) where T<:Real\n\nk^th-order lagrangian interpolation of the function f(r) at position r \n\nf[1:N] : the function f(r) tabulated in forward order on a Grid of N points\nfwd using fwd-difference notation  \nbwd using bwd-difference notation\n\nExample:\n\njulia> grid = castGrid(1, 1000, Float64; h = 0.01, rmax=25, msg=false);\n\njulia> r = grid.r;\n\njulia> f = [exp(-r[n]) for n=1:grid.N];\n\njulia> rv = 1.0;\n\njulia> grid_interpolation(f, grid, rv, fwd) ≈ exp(-rv)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#CamiDiff.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Documentation","title":"CamiDiff.grid_differentiation","text":"grid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T<:real\n\nk^th-order lagrangian derivative of the function f(r) over the range 0  r  rmax\n\nf[1:N] : the function f(r) tabulated in forward order on a Grid of N points\n\nExample:\n\njulia> grid = castGrid(3, 1001, Float64; h=2π/1000.0, r0=1.0, msg=false);\n\njulia> f = [sin(grid.r[i]) for i=1:grid.N]\n\njulia> f′ = [cos(grid.r[i]) for i=1:grid.N]\n\njulia> grid_differentiation(f, grid) ≈ f′\ntrue\n\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, rv::T, notation=fwd; k=5) where T<:Real\n\nk^th-order lagrangian derivative of the function f(r) at position rv\n\nf[1:N] : the function f(r) tabulated in forward order on a Grid of N points\nfwd using fwd-difference notation  \nbwd using bwd-difference notation\n\nExample:\n\njulia> grid = castGrid(3, 1001, Float64; h=2π/1000.0, r0=1.0, msg=false);\n\njulia> f = [sin(grid.r[i]) for i=1:grid.N];\n\njulia> grid_differentiation(f, grid, float(π), fwd) ≈ cos(π)\ntrue\n\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, n::Int, notation=fwd; k=5) where T<:Real\n\nk^th-order lagrangian derivative of the function f(r) at grid position n\n\nf[1:N] : the function f(r) tabulated in forward order on a Grid of N points\nfwd using fwd-difference notation  \nbwd using bwd-difference notation\n\nExample:\n\njulia> grid = castGrid(3, 1001, Float64; h=2π/1000.0, r0=1.0, msg=false);\n\njulia> f = [sin(grid.r[i]) for i=1:grid.N];\n\njulia> f′ = [cos(grid.r[i]) for i=1:grid.N];\n\njulia> grid_differentiation(f, grid, 500, fwd) ≈ f′[500]\ntrue\n\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int; k=5) where T<:Real\ngrid_differentiation(f::Vector{T}, grid::Grid{T}, itr::UnitRange; k=5) where T<:Real\n\nk^th-order lagrangian derivative of the function f(r) over the grid range n1 ≤ n ≤ n2\n\nf[1:N] : the function f(r) tabulated in forward order on a Grid of N points\nn1=itr.start, n2=itr.stop.  \n\n\n\n\n\n","category":"method"},{"location":"pages/documentation/#CamiDiff.grid_integration-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T<:Real","page":"Documentation","title":"CamiDiff.grid_integration","text":"grid_integration(f::Vector{T}, grid::Grid{T}) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int) where T<:Real\ngrid_integration(f::Vector{T}, grid::Grid{T}, itr::UnitRange) where T<:Real\n\nIntegral of the analytic function f(r) tabulated on a generally nonlinear  Grid and evaluated with the generalized trapezoidal rule optimized  with endpoint correction by the weightsvector grid.epw,\n\n    _0^r_n f(r) dr = _0^n f(x) r^prime(x) dx\n\nHere, the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see trapezoidal_integration). The rule is exact for polynomial functions of degree d=0 1 k-1, where k= grid.epn. For k=1 the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).\n\nExamples:\n\njulia> ftest(r) = sqrt(2.0/π) * exp(-r^2/2.0);\n\njulia> grid1 = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);\nGrid created: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1\n\njulia> grid2 = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);\nGrid created: truncated-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1\n\njulia> grid3 = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);\nGrid created: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1\n\njulia> grid4 = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);\nGrid created: polynomial, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001\n\njulia> r1 = grid1.r;\njulia> r2 = grid2.r;\njulia> r3 = grid3.r;\njulia> r4 = grid4.r;\njulia> f1 = [ftest(r1[n]) for n=1:grid1.N];\njulia> f2 = [ftest(r2[n]) for n=1:grid2.N];\njulia> f3 = [ftest(r3[n]) for n=1:grid3.N];\njulia> f4 = [ftest(r4[n]) for n=1:grid4.N];\njulia> o1 = grid_integration(f1, grid1);\njulia> o2 = grid_integration(f2, grid2);\njulia> o3 = grid_integration(f3, grid3, 1:900);\njulia> o4 = grid_integration(f4, grid4, 1:900);\n\njulia> println(\"integral on \" * grid1.name * \" grid = \", o1)\nintegral on exponential grid = 1.0\n\njulia> println(\"integral on \" * grid2.name * \" grid = \", o2)\nintegral on truncated-exponential grid: 1.0\n\njulia> println(\"integral on \" * grid3.name * \" grid = \", o3)\nintegral on linear (uniform) grid = 1.000000000000003\n\njulia> println(\"integral on \" * grid3.name * \" grid = \", o4)\nintegral on polynomial grid = 1.0000000000000013\n\n\n\n\n\n","category":"method"},{"location":"pages/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"pages/","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CamiDiff","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiDiff.jl is a Julia package for one-dimensional finite-difference analysis. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Install","page":"Home","title":"Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is installed using the Julia package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"CamiDiff\")\n\njulia> using CamiDiff","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CamiDiff has been developed to analyze mathematical functions, provided by the user  in tabulated form. The package is based on finite-difference analysis methods in one dimension. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Throughout the documentation f(x) will be the 'function of interest' under investigation. In tabulated  form we write fn. This form can be regarded as the result of the discretization of f(x)  on a Grid of N points, addressable by the grid index n = 1  N. The Grid  can be linear (uniform) or non-linear as specified by a gridfunction - see Discretization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The current implementation of CamiDiff was developed for real functions of a single variable.  A set of four predefined gridfunctions is included in the package: 'exponential',  'truncated-exponential', 'linear' and 'polynomial'. These are restricted to the domain 0 ).  When applicable, we shall underline this restriction to the non-negative domain by using the variable r  rather than x, writing f(r) rather than f(x), with the implicit condition r  0.","category":"page"},{"location":"#Discretization","page":"Home","title":"Discretization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Mathematically, the discretization is based on the map n  x which defines the discrete function","category":"page"},{"location":"","page":"Home","title":"Home","text":"xn = s_0 * g(tn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here g(t) is called the gridfunction and s_0 the scaling factor. The gridfunction  is defined as a (generally nonlinear) function running through the origin: g(0) = 0. Its argument is  the ticks function","category":"page"},{"location":"","page":"Home","title":"Home","text":"tn  (nu) * h","category":"page"},{"location":"","page":"Home","title":"Home","text":"which is a discrete linear function, where u is called the index base and h the step size. Writing","category":"page"},{"location":"","page":"Home","title":"Home","text":"fn = f(xn)","category":"page"},{"location":"","page":"Home","title":"Home","text":"we recognize in fn a discrete function representing the function f(x) at position xn. This represents  the tabulated function to be provided by the user. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"NB. The discrete function fn is defined on the grid of natural numbers, a uniform grid with unit step size.  This uniformity greatly simplifies the numerical analysis. The stepsize of the ticks function, h, determines  the coarseness of the grid. The results of a finite-difference calculation on a coarse grid will be less accurate  than those on a fine grid, but the algorithm is identical, because the relevant finite-difference expansions only  depend implicitly on h. Since Julia uses unit-based indexing (u = 1), the index  convention implies f1 = f(0).  ","category":"page"},{"location":"#Grid","page":"Home","title":"Grid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Grid object is the backbone for numerical procedures on the real domain 0 ). Its principal fields  are grid.r, grid.r′ and grid.r′′. These are discrete functions of N elements representing the grid function  and its first two derivatives. The function fn is tabulated on this Grid and the function  rn= grid.r represents the transformation by the gridfunction. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the Grid is specified, three Grid operations are at our disposal - see Documentation","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_interpolation(f, rval, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_differentiation(f, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"grid_integration(f, grid)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grid{T}\ncastGrid(ID::Int, N::Int, T::Type; h=1, rmax=10, p=5, polynom=[0,1], epn=5, k=5, msg=false)\ngridfunction(ID::Int, n::Int, T::Type; h=1, p=5, polynom=[0,1], deriv=0)\ngridtypename(ID::Int)\ngridtypeID(name::String)\ngridPos(rval::T, grid::Grid{T}) where T<:Real\nfracPos(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T<:Real","category":"page"},{"location":"#CamiDiff.Grid","page":"Home","title":"CamiDiff.Grid","text":"Grid(ID, name, T, N, r, r′, r′′, h, r0, epn, epw, k, p, polynom)\n\nType with fields:\n\n.ID:    grid identifer name (::Int)\n.name:  grid identifer name (::String)\n.T:     gridtypename (::Type)\n.N:     number of grid points (::Int)\n.r:   tabulated grid function (::Vector{T})\n.r′:   tabulated first derivative of grid function (::Vector{T})\n.r′′:   tabulated second derivative of grid function (::Vector{T})\n.h :    grid step multiplyer (::T)\n.r0:    grid scale factor (::T)\n.epn:   number of endpoints used for trapezoidal endpoint correction (must be odd) (::Int)\n.epw:   trapezoidal endpoint weights for n=1:epn (::Vector{Vector{T}})\n.k:     finite-difference order (::Int)\n.p:     only for truncated-exponential grid; truncation power (::Int)\n.polynom: only for polynomial grid: polynom (::Vector{T})\n\nThe object Grid is best created with the function castGrid.\n\n\n\n\n\n","category":"type"},{"location":"#CamiDiff.castGrid-Tuple{Int64, Int64, Type}","page":"Home","title":"CamiDiff.castGrid","text":"castGrid(ID::Int, N::Int, T::Type; h=1, rmax=10, p=5, polynom=[0,1], epn=5, k=5, msg=false)\ncastGrid(name::String, N::Int, T::Type; h=1, rmax=10, p=5, polynom=[0,1], epn=5, k=5, msg=false)\n\nMethod to create a Grid object that covers the radial range [0, rmax] with N points.\n\nID = 1: exponential, ID = 2: truncated-exponential, ID = 3: linear (uniform) ID = 4: polynomial\n\nExamples:\n\njulia> grid = castGrid(1, 1000, Float64; h = 0.005, rmax = 10, msg=true);\nGrid: exponential, Float64, rmax = 10.0, Ntot = 1000, h = 0.005, r0 = 0.0681789\n\njulia> grid = castGrid(\"exponential\", 1000, Float64; h = 0.005, rmax = 10, msg=true);\nGrid: exponential, Float64, rmax = 10.0, Ntot = 1000, h = 0.005, r0 = 0.0681789\n\njulia> grid = castGrid(2, 1000, Float64; h = 0.005, rmax = 10, p=5, msg=true);\nGrid: truncated-exponential, Float64, rmax = 10.0, Ntot = 1000, p = 5, h = 0.005, r0 = 0.111\n\njulia> grid = castGrid(3, 1000, Float64; h = 0.1, rmax = 10, msg=true);\nGrid: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1001\n\njulia> grid = castGrid(4, 1000, Float64; h = 0.1, rmax = 10, polynom=[0,0,1], msg=true);\nGrid: polynomial of degree 2, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001002\n\njulia> r = grid.r[1:4]; println(\"r = \", r)\nr = [0.0, 1.002003004005006e-5, 4.008012016020024e-5, 9.018027036045053e-5]\n\njulia> r = grid.r[997:1000]; println(\"r = \", r)\nr = [9.9400301202103, 9.96000004008012, 9.979990000010021, 10.0] # note the end of the range (r = rmax) \n\njulia> r′= grid.r′[1:4]; println(\"r′ = \", r′)\nr′ = [0.0, 2.0040060080100123e-5, 4.008012016020025e-5, 6.012018024030035e-5]\n\njulia> r′′= grid.r′′[1:4]; println(\"r′′ = \", r′′)\nr′′ = [2.004006008010012e-5, 2.004006008010012e-5, 2.004006008010012e-5, 2.004006008010012e-5]\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridfunction-Tuple{Int64, Int64, Type}","page":"Home","title":"CamiDiff.gridfunction","text":"gridfunction(ID::Int, n::Int, T::Type; h=1, p=5, polynom=[0,1], deriv=0)\n\nCamiDiff offers three internal grid functions:\n\nID = 1: exponential grid function,\n\n    g(t) = rmexp(t) - 1\n\nID = 2: truncated-exponential grid function of degree p (linear grid for p = 1),\n\n    g(t) = t + frac12t^2 +  + frac1pt^p\n\nID = 3: linear grid function,\n\n    g(t) = t\n\nID = 4: polynomial grid function of degree p = length(c)-1 defined by its CamiMath.polynom vector c = c_0 c_1c_2 c_p,\n\n    g(t) = c_0 + c_1 t + c_2 t^2 +  + c_p t^p\n\nwith c_0  0 because, by definition, all gridfunctions run through the origin, g(0) = 0. \n\nThe actual Grid is given by \n\n    rn = r_0 * g(tn)\n\nwhere tn = (n-1) * h is the ticks function for the unit-based indexing of Julia.\n\nNB. All gridfunctions satisfy the properties t1 = 0 and r1 = 0.\n\nExamples:\n\njulia> h = 0.1; r0=1.0; N=4; T=Float64;\n\njulia> r = [r0*gridfunction(1, n, T; h) for n=1:N]; println(\"r = \", r)\nr = [0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]\n\njulia> r′= r0 .* [r0*gridfunction(1, n, T; h, deriv=1) for n=1:N]; println(\"r′= \", r′)\nr′ = [0.1, 0.11051709180756478, 0.122140275816017, 0.13498588075760032]\n\njulia> r′′= [r0*gridfunction(1, n, T; h, deriv=2) for n=1:N]; println(\"r′′= \", r′′)\nr′′ = [0.010000000000000002, 0.011051709180756479, 0.012214027581601701, 0.013498588075760034]\n\njulia> r = [r0*gridfunction(4, n, T; h, polynom=[0,0,1]) for n=1:N]; println(\"r = \", r)\nr = [0.0, 0.010000000000000002, 0.04000000000000001, 0.09000000000000002]\n\njulia> r′= [r0*gridfunction(4, n, T; h, polynom=[0,0,1], deriv=1) for n=1:N]; println(\"r′= \", r′)\nr′= [0.0, 0.020000000000000004, 0.04000000000000001, 0.06000000000000001]\n\njulia> r′′= [r0*gridfunction(4, n, T; h, polynom=[0,0,1], deriv=2) for n=1:N]; println(\"r′′= \", r′′)\nr′′= [0.020000000000000004, 0.020000000000000004, 0.020000000000000004, 0.020000000000000004]\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridtypename-Tuple{Int64}","page":"Home","title":"CamiDiff.gridtypename","text":"gridtypename(ID::Int)\n\nName corresponding to the Grid ID.\n\nExample:\n\njulia> gridtypename(2)\n\"truncated-exponential\"\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridtypeID-Tuple{String}","page":"Home","title":"CamiDiff.gridtypeID","text":"gridtypeID(name::String)\n\nID corresponding to the gridtypename.\n\nExample:\n\njulia> gridtypeID(\"truncated-exponential\")\n2\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.gridPos-Union{Tuple{T}, Tuple{T, Grid{T}}} where T<:Real","page":"Home","title":"CamiDiff.gridPos","text":"gridPos(rval::T, grid::Grid{T}) where T<:Number\n\nThe approximate grid position defined as the largest integer n satisfying the  condition grid.r[n] < rval on the Grid.\n\nExample:\n\nConsider the exponential grid of 4 points defined by \n\njulia> grid = castGrid(\"exponential\", 4, Float64; h = 0.1, rmax = 2.0);\n\njulia> println(grid.r)\n[0.0, 0.6012192107114549, 1.265669197778149, 2.0]\n\nThe approximate grid position of the point r = 1.0 is n = 2 (larger than 0.6012192107114549 but smaller than 1.265669197778149).\n\njulia> r = 1.0;\n\njulia> n = gridPos(r, grid)\n2\n\n\n\n\n\n","category":"method"},{"location":"#CamiDiff.fracPos-Union{Tuple{T}, Tuple{Int64, T, Grid{T}}} where T<:Real","page":"Home","title":"CamiDiff.fracPos","text":"fracPos(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T<:Real\n\nFractional grid offset with respect to Grid position n.\n\nExample:\n\nConsider the exponential grid of 4 points defined by \n\njulia> grid = castGrid(\"exponential\", 4, Float64; h = 0.1, rmax = 2.0);\n\njulia> println(grid.r)\n[0.0, 0.6012192107114549, 1.265669197778149, 2.0]\n\nTe point r = 1.0 is located at approximate n n = 2,  with fractional position Δn = 0.6120806373655796.\n\njulia> r = 1.0;\n\njulia> n = gridPos(r, grid)\n2\n\njulia> Δn = fracPos(n, r, grid);\n\njulia> t = (n+Δn-1)*grid.h;\n\njulia> grid.r0 * (exp(t)-1) ≈ r\n\n\n\n\n\n","category":"method"},{"location":"#Finite-differences","page":"Home","title":"Finite differences","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Let f(x) be a real, regular function of the variable x.  The forward difference between f(x+h) and f(x) is defined as ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Δ f(x)=f(x+h)-f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, Δ is called the forward-difference operator. Likewise, one defines backward differences  with the backward-difference operator , ","category":"page"},{"location":"","page":"Home","title":"Home","text":" f(x)=f(x)-f(x-h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"We first focus on forward differences. The derivative of f(x) is given by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f^(x)=underseth0mathrmlimfracf(x+h)-f(x)h=undersetΔ x0mathrmlimfracΔ f(x)Δ x","category":"page"},{"location":"","page":"Home","title":"Home","text":"where h  Δx  0 is the difference interval. Introducing the differential operator, f^(x)  Df(x), we have ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dfracddx=undersetΔ x0mathrmlimfracΔΔ x=underseth0mathrmlimfracΔh","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"In terms of backward differences, the derivative of f(x) is given by ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f^(x)=underseth0mathrmlimfracf(x)-f(x-h)h=undersetΔ x0mathrmlimfrac f(x)Δ x","category":"page"},{"location":"","page":"Home","title":"Home","text":"where h  Δx  0 is the difference interval. Introducing the differential operator, f^(x)  Df(x), we have ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Dfracddx=undersetΔ x0mathrmlimfracΔ x=underseth0mathrmlimfrach","category":"page"},{"location":"#Translation-operators","page":"Home","title":"Translation operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Forward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"With regard to forward differences we rewrite the forward difference definition in the form of a forward translation,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x+h)=(1+Δ)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where T(1+Δ) is the forward translation operator. This operator shifts the function over the infinitesimal interval h to larger values of x. The translation operator can be expressed in terms of the differential operator as follows by Taylor expansion of f(x) about the point x, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x h)=(1 hD+tfrac12h^2D^2tfrac13h^3D^3+)f(x)=e^ hDf(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Comparing the operator expression for the forward translation with the Taylor expansion we obtain, by formal inversion of the operator T, an operator identity for the inverted translation operator T^-1,    ","category":"page"},{"location":"","page":"Home","title":"Home","text":"T(1+Δ)=e^hDT^-1=e^-hD=(1+Δ)^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since Δ depends implicitly on h, the explicit dependence on h can be replaced by an implicit dependence on h through an expansion in powers of Δ ,","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x-h)=(1+Δ)^-1f(x)=(1-Δ+Δ^2-Δ^3+)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By choosing the proper expansion order, f(x-h) can be approximated to any desired level of accuracy.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Backward difference notation","category":"page"},{"location":"","page":"Home","title":"Home","text":"For backward differences, we rewrite the backward-difference definition in the form ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x-h)=(1-)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where B(1-) is the backward translation operator. Comparing this backward translation with the Taylor expansion we obtain, by formal inversion of the operator B, an operator identity for the forward translation operator T, ","category":"page"},{"location":"","page":"Home","title":"Home","text":"B(1-)=e^-hD=T^-1T=e^hD=(1+)^-1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note how the backward translation operator was identified with the inverse forward translation operator, B=T^-1. As with forward differences, the explicit dependence on h can be replaced by an implicit dependence on h through an expansion in powers of , ","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(x+h)=(1-)^-1f(x)=(1++^2+^3+)f(x)","category":"page"},{"location":"","page":"Home","title":"Home","text":"By choosing the proper expansion order, f(x+h) can be approximated to any desired level of accuracy. ","category":"page"}]
}
