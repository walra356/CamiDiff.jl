<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · CamiDiff.jl</title><meta name="title" content="Documentation · CamiDiff.jl"/><meta property="og:title" content="Documentation · CamiDiff.jl"/><meta property="twitter:title" content="Documentation · CamiDiff.jl"/><meta name="description" content="Documentation for CamiDiff.jl."/><meta property="og:description" content="Documentation for CamiDiff.jl."/><meta property="twitter:description" content="Documentation for CamiDiff.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CamiDiff.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Discretization"><span>Discretization</span></a></li><li><a class="tocitem" href="#Finite-differences"><span>Finite differences</span></a></li><li><a class="tocitem" href="#Translation-operators"><span>Translation operators</span></a></li><li><a class="tocitem" href="#Finite-differences-2"><span>Finite differences</span></a></li><li><a class="tocitem" href="#Finite-difference-expansions"><span>Finite difference expansions</span></a></li><li><a class="tocitem" href="#Lagrange-interpolation"><span>Lagrange interpolation</span></a></li><li><a class="tocitem" href="#Lagrangian-differentiation"><span>Lagrangian differentiation</span></a></li><li><a class="tocitem" href="#Integration"><span>Integration</span></a></li><li><a class="tocitem" href="#Adams-Method"><span>Adams Method</span></a></li></ul></li><li><a class="tocitem" href="../grid/">Grid</a></li><li><a class="tocitem" href="../">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/walra356/CamiDiff.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/walra356/CamiDiff.jl/blob/main/docs/src/man/documentation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><p>Mathematically, the discretization is based on the map <span>$n ↦ x,$</span> which defines the discrete function</p><p class="math-container">\[x[n] = s_0 * g(t[n]).\]</p><p>Here <span>$g(t)$</span> is called the <a href="../grid/#CamiDiff.gridfunction-Tuple{Int64, Int64, Type}"><code>gridfunction</code></a> and <span>$s_0$</span> the <em>scaling factor</em>. The <a href="../grid/#CamiDiff.gridfunction-Tuple{Int64, Int64, Type}"><code>gridfunction</code></a>  is defined as a (generally nonlinear) function <em>running through the origin</em>: <span>$g(0) = 0$</span>. Its argument is  the <em>ticks function</em></p><p class="math-container">\[t[n] ≡ (n−u) * h,\]</p><p>which is a discrete <em>linear</em> function, where <span>$u$</span> is called the <em>index base</em> and <span>$h$</span> the <em>step size</em>. Writing</p><p class="math-container">\[f[n] = f(x[n]),\]</p><p>we recognize in <span>$f[n]$</span> a discrete function representing the function <span>$f(x)$</span> at position <span>$x[n]$</span>. This represents  the tabulated function to be provided by the user. </p><p>NB. The discrete function <span>$f[n]$</span> is defined on the <em>grid of natural numbers</em>, a uniform grid with unit step size.  This uniformity greatly simplifies the numerical analysis. The stepsize of the <em>ticks function</em>, <span>$h$</span>, determines  the <em>coarseness</em> of the grid. The results of a finite-difference calculation on a coarse grid will be less accurate  than those on a fine grid, but the algorithm is identical, because the relevant finite-difference expansions only  depend <em>implicitly</em> on <span>$h$</span>. Since <a href="http://julialang.org">Julia</a> uses unit-based indexing (<span>$u = 1$</span>), the index  convention implies <span>$f[1] = f(0)$</span>.  </p><h2 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h2><p>Let <span>$f(x)$</span> be a real, regular function of the variable <span>$x$</span>.  The <em>forward difference</em> between <span>$f(x+h)$</span> and <span>$f(x)$</span> is defined as </p><p class="math-container">\[Δ f(x)=f(x+h)-f(x).\]</p><p>Here, <span>$Δ$</span> is called the <em>forward-difference operator</em>. Likewise, one defines backward differences  with the <em>backward-difference operator</em> <span>$∇$</span>, </p><p class="math-container">\[∇ f(x)=f(x)-f(x-h).\]</p><p><strong>Forward difference notation</strong></p><p>We first focus on <em>forward differences</em>. The derivative of <span>$f(x)$</span> is given by </p><p class="math-container">\[f^′(x)=\underset{h→0}{\mathrm{lim}}\,\frac{f(x+h)-f(x)}{h}=\underset{Δ x→0}{\mathrm{lim}}\,\frac{Δ f(x)}{Δ x},\]</p><p>where <span>$h ≡ Δx ≥ 0$</span> is the <em>difference interval</em>. Introducing the differential operator, <span>$f^′(x) ≡ Df(x)$</span>, we have </p><p class="math-container">\[D≡\frac{d}{dx}=\underset{Δ x→0}{\mathrm{lim}}\,\frac{Δ}{Δ x}=\underset{h→0}{\mathrm{lim}}\,\frac{Δ}{h}.\]</p><p><strong>Backward difference notation</strong></p><p>In terms of <em>backward differences</em>, the derivative of <span>$f(x)$</span> is given by </p><p class="math-container">\[f^′(x)=\underset{h→0}{\mathrm{lim}}\,\frac{f(x)-f(x-h)}{h}=\underset{Δ x→0}{\mathrm{lim}}\,\frac{∇ f(x)}{Δ x},\]</p><p>where <span>$h ≡ Δx ≥ 0$</span> is the <em>difference interval</em>. Introducing the differential operator, <span>$f^′(x) ≡ Df(x)$</span>, we have </p><p class="math-container">\[D≡\frac{d}{dx}=\underset{Δ x→0}{\mathrm{lim}}\,\frac{∇}{Δ x}=\underset{h→0}{\mathrm{lim}}\,\frac{∇}{h}.\]</p><h2 id="Translation-operators"><a class="docs-heading-anchor" href="#Translation-operators">Translation operators</a><a id="Translation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Translation-operators" title="Permalink"></a></h2><p><strong>Forward difference notation</strong></p><p>With regard to <em>forward differences</em> we rewrite the forward difference definition in the form of a <em>forward translation</em>,</p><p class="math-container">\[f(x+h)=(1+Δ)f(x),\]</p><p>where <span>$T≡(1+Δ)$</span> is the <em>forward translation operator</em>. This operator shifts the function over the infinitesimal interval <span>$h$</span> to larger values of <span>$x$</span>. The translation operator can be expressed in terms of the differential operator as follows by Taylor expansion of <span>$f(x)$</span> about the point <span>$x$</span>, </p><p class="math-container">\[f(x± h)=(1± hD+\tfrac{1}{2}h^2D^2±\tfrac{1}{3!}h^3D^3+⋯)f(x)=e^{± hD}f(x).\]</p><p>Comparing the operator expression for the <em>forward</em> translation with the Taylor expansion we obtain, by formal inversion of the operator <span>$T$</span>, an operator identity for the inverted translation operator <span>$T^{-1}$</span>,    </p><p class="math-container">\[T≡(1+Δ)=e^{hD}\,\,\,⇒\,\,\,T^{-1}=e^{-hD}=(1+Δ)^{-1}.\]</p><p>Since <span>$Δ$</span> depends implicitly on <span>$h$</span>, the explicit dependence on <span>$h$</span> can be replaced by an implicit dependence on <span>$h$</span> through an expansion in powers of <span>$Δ$</span> ,</p><p class="math-container">\[f(x-h)=(1+Δ)^{-1}f(x)=(1-Δ+Δ^{2}-Δ^3+⋯)f(x).\]</p><p>By choosing the proper expansion order, <span>$f(x-h)$</span> can be approximated to any desired level of accuracy.</p><p><strong>Backward difference notation</strong></p><p>For <em>backward differences</em>, we rewrite the backward-difference definition in the form </p><p class="math-container">\[f(x-h)=(1-∇)f(x),\]</p><p>where <span>$B≡(1-∇)$</span> is the <em>backward translation operator</em>. Comparing this <em>backward</em> translation with the Taylor expansion we obtain, by formal inversion of the operator <span>$B$</span>, an operator identity for the <em>forward</em> translation operator <span>$T$</span>, </p><p class="math-container">\[B≡(1-∇)=e^{-hD}=T^{-1}\,\,\,⇒\,\,\,T=e^{hD}=(1+∇)^{-1}.\]</p><p>Note how the <em>backward</em> translation operator was identified with the inverse <em>forward</em> translation operator, <span>$B=T^{-1}$</span>. As with forward differences, the explicit dependence on <span>$h$</span> can be replaced by an implicit dependence on <span>$h$</span> through an expansion in powers of <span>$∇$</span>, </p><p class="math-container">\[f(x+h)=(1-∇)^{-1}f(x)=(1+∇+∇^{2}+∇^3+⋯)f(x).\]</p><p>By choosing the proper expansion order, <span>$f(x+h)$</span> can be approximated to any desired level of accuracy. </p><h2 id="Finite-differences-2"><a class="docs-heading-anchor" href="#Finite-differences-2">Finite differences</a><a class="docs-heading-anchor-permalink" href="#Finite-differences-2" title="Permalink"></a></h2><p>Let <span>$f[n]$</span> be the &#39;function of interest&#39;, tabulated in <em>forward order</em>   (growing index) on the <em>grid of natural numbers</em>.</p><p><strong>Forward difference notation</strong></p><p>The <em>forward translation</em> from position <span>$n-1$</span> to position <span>$n$</span> on  the grid is expressed by the relation</p><p class="math-container">\[f[n] = (1 + Δ) f[n-1] ,\]</p><p>where <span>$Δ$</span> is the forward difference operator. By formal inversion   we find</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n],\]</p><p>where <span>$Δ^k$</span> is the  <span>$k^{th}$</span>-<em>order forward difference</em> defined as a <em>weighted sum</em> over the function values <span>$f[n:n+k]$</span> (involving <span>$k+1$</span> points appearing in regular=forward order),</p><p class="math-container">\[\begin{aligned}
Δ^k f[n] &amp;= f[n+k] + c_1^kf[n+k-1] + ⋯  + f[n] \\
         &amp;= f[n] + c_{k-1}^kf[n+1] + ⋯  + f[n+k] = \sum_{j=0}^{k} c_{k-j}^k f[n+j],
\end{aligned}\]</p><p>where the <span>$k+1$</span> coefficients <span>$c_{k-j}^k=(-1)^k c_j^k$</span>,  with</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j},\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) defining the summation, with special values  <span>$c_{0}^{k}≡1$</span> and <span>$c_{k}^{k}≡(-1)^{k}$</span>.</p><p>In inner product form the result becomes</p><p class="math-container">\[Δ^k f[n]=\bar{c}^k \cdot f[n:n+k],\]</p><p>where <span>$\bar{c}^k  ≡ [c_k^k,⋯\ c_0^k]$</span>.</p><hr/><p><strong>Backward difference notation</strong></p><p>The <em>backward translation</em> from position <span>$n$</span> to position <span>$n-1$</span> on  the grid is expressed by the relation</p><p class="math-container">\[f[n] = (1 - ∇) f[n+1],\]</p><p>where <span>$∇$</span> is the backward difference operator.  By formal inversion   we obtain in this case</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><p>where <span>$∇^k$</span> is the  <span>$k^{th}$</span>-<em>order backward difference</em> defined as a <em>weighted sum</em> over the function values <span>$f[n:-1:n-k]$</span> (involving  <span>$k+1$</span> points appearing in reversed order),</p><p class="math-container">\[∇^k f[n] = f[n] + c_1^kf[n-1] + ⋯ + f[n-k]
= \sum_{j=0}^{k} c_j^kf[n-j],\]</p><p>where the <span>$k+1$</span> coefficients <span>$c_j^k$</span> are the <em>summation weights</em>  (short: <em>weights</em>) defining the summation. </p><p>In inner product form the result becomes</p><p class="math-container">\[∇^k f[n] = c^k \cdot f[n:-1:n-k] =\bar{c}^k \cdot f[n-k:n],\]</p><p>where <span>$c^k  ≡ [c_0^k,⋯\ c_k^k]$</span>.</p><p>Coefficients:</p><p><a href="#CamiDiff.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k, j)</code></a> <span>$→ c^k ≡ [c_0^k,⋯\ c_k^k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_weight-Tuple{Int64, Int64}" href="#CamiDiff.fdiff_weight-Tuple{Int64, Int64}"><code>CamiDiff.fdiff_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_weight(k::Int, j::Int)</code></pre><p>Finite difference weight coefficient,</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j}.\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; c(k,j) = fdiff_weight(k,j);

julia&gt; a = [[c(k,j) for j=0:k] for k=0:3]
4-element Vector{Vector{Int64}}:
 [1]
 [1, -1]
 [1, -2, 1]
 [1, -3, 3, -1]

julia&gt; b = [[c(k,k-j) for j=0:k] for k=0:3]
4-element Vector{Vector{Int64}}:
 [1]
 [-1, 1]
 [1, -2, 1]
 [-1, 3, -3, 1]

julia&gt; b == reverse.(a)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L31-L60">source</a></section></article><h2 id="Finite-difference-expansions"><a class="docs-heading-anchor" href="#Finite-difference-expansions">Finite difference expansions</a><a id="Finite-difference-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-expansions" title="Permalink"></a></h2><p>Finite-difference calculus builds on <em>finite-difference expansions</em> on a uniform grid.</p><p><strong>Forward difference notation</strong></p><p>In terms of forward differences the generic form of the finite-difference expansion is given by</p><p class="math-container">\[\sum_{p=0}^{\infty}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}Δ^{p}f[n]+⋯.\]</p><p>Evaluated to order <span>$k$</span>, the expansion is defined by <span>$k+1$</span> <em>finite-difference expansion coefficients</em>,  supplied by the user in the form of the expansion vector, <span>$α = [α_{0},⋯\ α_{k}]$</span>. This vector contains the coefficients in the <em>regular</em> ordering of <em>growing index</em>. It takes some bookkeeping to rewrite the expansion  as a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values</em> <span>$f[n:n+k]$</span> (note the <em>regular</em> ordering of <em>growing</em> grid position). After substituting the forward difference, <span>$Δ = f[n+1] - f[n]$</span>,  the finite-difference expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}\sum_{j=0}^{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}α_{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j],\]</p><p>where the weighted summation is defined by the <em>weights</em></p><p class="math-container">\[F_{j}^{k}=\sum_{p=j}^{k}α_{p}c_{p-j}^{p}
=\sum_{p=j}^{k}(-1)^{p+j}\binom{p}{j}α_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form, the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$F^k  ≡ [F_0^k,⋯\ F_k^k]$</span>.</p><hr/><p>Summary:</p><p>In <code>CamiDiff</code>, any finite-difference expansion is defined by a (user-supplied) <code>polynom</code>  (the vector of expansion coefficients). In <em>fwd-difference</em> notation we write</p><p><code>polynom</code> <span>$→ α ≡ [α_0,⋯\ α_k]$</span>.</p><p>Examples are given below. Once we have the <em>coefficients</em> (in the form of the <code>polynom</code>),  we can calculate the <em>weights</em> (the <em>fwd-difference</em> weights vector) in reg-fwd-notation,</p><p><code>weights =</code> <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, fwd, reg)</code></a> <span>$→ F^k ≡ [F^k_0,⋯\ F^k_k]$</span></p><p>and the result of the expansion is obtained by evaluating the following inner product (in <em>fwd-difference</em> notation)  </p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n] = F^k \cdot f[n:n+k].\]</p><hr/><p>Examples:</p><p>The <code>polynom</code>s of four common expansions in <em>fwd-difference</em> notation are:</p><p>interpolation: <a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ α ≡ [α_0(σ),⋯\ α_k(σ)]$</span></p><p>differentiation: <a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ α ≡ [α_0(σ),⋯\ α_k(σ)]$</span></p><p>Adams-Bashford: <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k, fwd)</code></a> <span>$→ α ≡ [α_0,⋯\ α_k]$</span></p><p>Adams-Moulton: <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k, fwd)</code></a> <span>$→ α ≡ [α_0,⋯\ α_k]$</span></p><p><strong>Backward difference notation</strong></p><p>In terms of backward differences the generic form of the finite-difference expansion is given by</p><p class="math-container">\[\sum_{p=0}^{\infty}β_{p}∇^{p}f[n]=\sum_{p=0}^{k}β_{p}∇^{p}f[n]+⋯.\]</p><p>In this case the <span>$k^{th}$</span>- order <em>finite-difference expansion</em> is defined by the (user-supplied) expansion vector <span>$β = [β_{0},⋯\ β_{k}]$</span>, containing the expansion coefficients  in <em>regular</em> ordering (<em>growing</em> index). The expansion can written as  a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values</em> <span>$f[n:-1:n-k]$</span> (note <em>reversed</em> ordering  of <em>decreasing</em> grid position). Substituting the definition of the backward difference, <span>$∇ = f[n] - f[n-1]$</span>,  the finite-difference expression takes the form</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{p=0}^{k}β_{p}\sum_{j=0}^{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}β_{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}B_{j}^{k}f[n-j],\]</p><p>where the <em>weights</em> are given by</p><p class="math-container">\[B_{j}^{k}=\sum_{p=j}^{k}β_{p}c_{j}^{p}
=\sum_{p=j}^{k}(-1)^{j}\binom{p}{j}β_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form, the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^k B_j^k f[n-j]
=\bar{B}^k \cdot f[n-k:n],\]</p><p>where <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> is the <em>weights vector</em> <span>$B^{k} ≡ [B_0^k,⋯\ B_k^k]$</span> tabulated  in reversed order.</p><p>The relation between <span>$B^k$</span> and <span>$F^k$</span> depends on the relation between the expansion polynoms <span>$α$</span> and <span>$β$</span>, which is not unique (it depends on the expansion under consideration).</p><hr/><p>Summary:</p><p>In <code>CamiDiff</code>, any finite-difference expansion is defined by a (user-supplied) <code>polynom</code>  (the vector of expansion coefficients). In <em>bwd-difference</em> notation we write</p><p><code>polynom</code> <span>$→ β ≡ [β_0,⋯\ β_k]$</span>.</p><p>Examples are given below. Once we have the <em>coefficients</em> (in the form of <code>polynom</code>) we can calculate the <em>weights</em> (the <em>bwd-difference</em> weights vector) in rev-bwd-notation,</p><p><code>weights =</code> <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, bwd, rev)</code></a> <span>$→ \bar{B}^k(σ) ≡ [B_k^k(σ),⋯\ B_0^k(σ)]$</span>,</p><p>and the result of the expansion is obtained by evaluating the following inner product (in <em>bwd-difference</em> notation),</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n] = \bar{B}^k(σ) \cdot f[n-k:n].\]</p><p>Examples:</p><p>The <code>polynom</code>s of four common expansions in <em>bwd-difference</em> notation are:</p><p>interpolation: <a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span></p><p>differentiation: <a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(σ, k, bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span></p><p>Adams-Bashford: <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k, bwd)</code></a> <span>$→ β(σ) ≡ [β_0,⋯\ β_k]$</span></p><p>Adams-Moulton: <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k, bwd)</code></a><span>$→ β(σ) ≡ [β_0,⋯\ β_k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_expansion_weights" href="#CamiDiff.fdiff_expansion_weights"><code>CamiDiff.fdiff_expansion_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_expansion_weights(polynom [, notation=bwd [, ordering=rev]])</code></pre><p>Weights vector corresponding to the expansion coefficient vector <code>polynom</code> of a (user-defined) finite-difference expansion.</p><p><strong>Forward-difference notation</strong> (<code>notation = fwd</code>)</p><p>The weights vector <span>$F^k ≡ [F_k^k,⋯\ F_0^k]$</span> corresponds to the expansion coefficient  vector <span>$α ≡ [α_0,⋯\ α_k]$</span> of the <span>$k^{th}$</span>-order <em>forward-difference</em> expansion (<code>polynom = α</code>).</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytic function <span>$f$</span> tabulated in regular=<em>forward</em> order.</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(α, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where <span>$α ≡ [α_0,⋯\ α_k]$</span> has to be supplied by the user in combination with <code>fwd</code> to indicate that the weights must be evaluated in forward-difference notation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>The weights vector <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> corresponds to the expansion coefficient  vector <span>$β ≡ [β_0,⋯\ β_k]$</span> of the <span>$k^{th}$</span>-order <em>backward-difference</em> expansion (<code>polynom = β</code>).</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^{k}B_{j}^kf[n-j]
=\bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where <span>$β ≡ [β_0,⋯\ β_k]$</span> has to be supplied by the user in combination with <code>bwd</code> to indicate that the weights must be evaluated in backward-difference notation.</p><p><strong>Example:</strong></p><p>Consider the expansions,</p><p class="math-container">\[\begin{aligned}
f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n]&amp;=F^{k} \cdot f[n:n+k],\\
f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n]&amp;=\bar{B}^k \cdot f[n-k:n].
\end{aligned}\]</p><pre><code class="nohighlight hljs">julia&gt; f = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100];

julia&gt; α = [1,-1,1,-1,1];

julia&gt; Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
Fk = [5, -10, 10, -5, 1]

julia&gt; β = [1,1,1,1,1];

julia&gt; revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
revBk = [1, -5, 10, -10, 5]

julia&gt; Fk ⋅ f[7:11]
25

julia&gt; revBk ⋅ f[1:5]
25

julia&gt; f[6]
25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L111-L188">source</a></section></article><h2 id="Lagrange-interpolation"><a class="docs-heading-anchor" href="#Lagrange-interpolation">Lagrange interpolation</a><a id="Lagrange-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-interpolation" title="Permalink"></a></h2><p>The <em>Lagrange polynomial</em> of degree <span>$k$</span> on a uniform grid is the polynomial running  through <span>$k+1$</span> subsequent points on the grid. We derive expressions for  interpolation in both forward- and backward-difference notation. Beware  that Lagrange interpolation becomes inaccurate if the tabulated function cannot be  approximated by a polynomial of degree <span>$k$</span>.</p><p><strong>Forward difference notation</strong></p><p>Starting from the forward translation expression</p><p class="math-container">\[f[n]=(1+Δ)f[n-1],\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n-1] = (1 + Δ)^{-1} f[n] ≡ \sum_{p=0}^{\infty}(-1)^p Δ^p f[n]+⋯,\]</p><p class="math-container">\[f[n-2] = (1 + Δ)^{-2} f[n] ≡ \sum_{p=0}^{\infty}(-1)^p pΔ^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$p$</span> is called the order of the expansion and <span>$n$</span> is the index of the reference position. For interpolation position <span>$v=n-σ$</span> (where <span>$σ$</span> may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n-σ] = (1 + Δ)^{-σ} f[n] ≡ \sum_{p=0}^{\infty} (-1)^p\ l_p(σ) Δ^p f[n],\]</p><p>where <span>$α_p(σ) = (-1)^p\ l_p(σ)$</span> is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian interpolation. Here we define </p><p class="math-container">\[l_p(σ) ≡ (σ)_p/p!\,,\]</p><p>with</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol <code>CamiMath.pochhammer</code>. Note that for <span>$σ = 1$</span> we find  <span>$α_p ≡ α_p(1) ≡ (-1)^p$</span>, which are the coefficients for the &#39;next-point&#39; expansion. </p><p>For <span>$-k ≤ σ ≤ 0$</span> the method can be used for <em>interpolation</em> over the grid position interval  <span>$n ≤ v ≤ n+k$</span>. Outside this interval, in particular for <span>$σ &gt; 0$</span>, the method amounts to  <em>extrapolation</em>. The method is most accurate for <span>$-1 ≤ σ ≤ 1$</span> (corresponding to the grid  position interval <span>$n-1 ≤ v ≤ n+1$</span>). Extrapolation to values <span>$v &gt; n+k$</span> is not recommended. </p><p>NB. The forward offset is defined as <span>$σ ≡ n-v$</span>.</p><hr/><p>Summary:</p><p>In <code>CamiDiff</code>, the <code>polynom</code> of the <em>fwd-interpolation</em> expansion is calculated with</p><p><code>polynom =</code> <a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ α(σ) ≡ [α_0(σ),⋯\ α_k(σ)]$</span>, where <span>$α_p(σ) = (-1)^p\ l_p(σ)$</span>.</p><p>Once we have the <em>coefficients</em> (in the form of <code>polynom</code>) we can calculate the <em>weights</em>  (the <em>fwd-interpolation</em> expansion weights vector) in reg-fwd-notation,</p><p><code>weights =</code> <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, fwd, reg)</code></a> <span>$→ F^k(σ) ≡ [F_0^k(σ),⋯\ F_k^k(σ)]$</span>,</p><p>and the <em>interpolated value</em> at grid position <code>n-σ</code> evaluates (in fwd-difference notation) to</p><p class="math-container">\[f[n-σ] = F^{k}(σ) \cdot f[n:n+k].\]</p><hr/><p><strong>Backward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1-∇)f[n+1].\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 - ∇)^{-1} f[n] ≡ \sum_{p=0}^{\infty}∇^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 - ∇)^{-2} f[n] ≡ \sum_{p=0}^{\infty}p∇^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$v=σ-n$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n+σ] = (1 - ∇)^{-σ} f[n] ≡ \sum_{p=0}^{\infty} l_p(σ) ∇^p f[n]⋯,\]</p><p>where <span>$β_p(σ) = l_p(σ)$</span> is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em>  for lagrangian interpolation, with <span>$(σ)_{p}$</span> being the Pochhammer symbol <code>CamiMath.pochhammer</code>.   Note that for <span>$σ = 1$</span> we find <span>$β_p ≡ β_p(1) ≡ 1$</span>, which are the coefficients for the  &#39;next-point&#39; expansion. </p><p>For <span>$-k ≤ σ ≤ 0$</span> the method can be used for <em>interpolation</em> over the grid position interval  <span>$n-k ≤ v ≤ n$</span>, outside this interval, in particular for <span>$σ &gt; 0$</span>, the method amounts to  <em>extrapolation</em>. The method is most accurate for <span>$-1 ≤ σ ≤ 1$</span> (corresponding to the grid  position interval <span>$n-1 ≤ v ≤ n+1$</span>). Extrapolation to values <span>$v &lt; n-k$</span> is not recommended. </p><p>NB. The backward offset is defined as <span>$σ ≡ -(n-v)$</span>.</p><hr/><p>Summary:</p><p>In <code>CamiDiff</code>, the <code>polynom</code> of the <em>bwd-interpolation</em> expansion is calculated with</p><p><code>polynom =</code> <a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span>, where <span>$β_p(σ) = l_p(σ)$</span>.</p><p>Once we have the <em>coefficients</em> (in the form of <code>polynom</code>) we can calculate the <em>weights</em> (the <em>bwd-interpolation</em> expansion weights vector) in rev-bwd-notation,</p><p><code>weights =</code> <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, bwd, rev)</code></a> <span>$→ \bar{B}^k(σ) ≡ [B_k^k(σ),⋯\ B_0^k(σ)]$</span>,</p><p>and the <em>interpolated value</em> at grid position <code>n+σ</code> evaluates  (in <em>bwd-difference</em> notation) to</p><p class="math-container">\[f[n+σ] = \bar{B}^k(σ) \cdot f[n-k:n].\]</p><h5 id="Example-1:"><a class="docs-heading-anchor" href="#Example-1:">Example 1:</a><a id="Example-1:-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:" title="Permalink"></a></h5><p>Demonstration of forward-difference <em>extrapolation</em> to &#39;next point&#39; (grid position &#39;v=n-1&#39;)</p><pre><code class="nohighlight hljs">julia&gt; n=5; v=4; k=5;

julia&gt; σ = n-v # fwd offset to &#39;next point&#39;
1

julia&gt; α = fdiff_interpolation_expansion_polynom(σ, k, fwd); println(&quot;α = $α&quot;)
α = [1, -1, 1, -1, 1, -1]

julia&gt; Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
Fk = [6, -15, 20, -15, 6, -1]

julia&gt; f = [v^2 for v=1:10]; println(&quot;f = $f&quot;)
f = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

julia&gt; Fk ⋅ f[n:n+k] == f[n-1] == v^2
true</code></pre><h5 id="Example-2:"><a class="docs-heading-anchor" href="#Example-2:">Example 2:</a><a id="Example-2:-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:" title="Permalink"></a></h5><p>Demonstration of backward-difference <em>interpolation</em> to grid position &#39;v=6.25`</p><pre><code class="nohighlight hljs">julia&gt; n=9; v=6.25; k=5;

julia&gt; σ = -(n-v) # bwd-offset of interpolation position
-1.25

julia&gt; β = fdiff_interpolation_expansion_polynom(σ, k, bwd); println(&quot;β = $β&quot;)
β = [1.0, -2.75, 2.40625, -0.6015625, -0.03759765625, -0.0093994140625]

julia&gt; revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
revBk = [0.0093994140625, -0.0845947265625, 0.845947265625, 0.281982421875, -0.0604248046875, 0.0076904296875]

julia&gt; f = [v^2 for v=1:10]; println(&quot;f = $f&quot;)
f = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

julia&gt; revBk ⋅ f[n-k:n] ≈ v^2
true</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real" href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiDiff.fdiff_interpolation_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_interpolation_expansion_polynom(σ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining the <span>$k^{th}$</span>-order (default <em>third</em> order) Lagrange-polynomial interpolation of a tabulated analytic function <span>$f[n]$</span> at offset <span>$σ$</span> with respect to index position <span>$n$</span>, which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n:n+k]$</span>. The interpolated value <span>$f[n-σ]$</span> is given by the forward-difference expansion</p><p class="math-container">\[f[n-σ] = \sum_{p=0}^k α_p(σ) Δ^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ α(σ) ≡ [α_0(σ),⋯\ α_k(σ)]$</span>. </p><p>Application: This polynom can serve to predict <code>f[n-1]</code> by <em>extrapolation</em> (using <span>$σ=1$</span>)  if <code>f[n:n+k]</code> are known. More generally, it can serve to <em>interpolate</em> to (real) positions  <span>$n ≤ v ≤ n+k$</span> (using <span>$-k ≤ σ ≤ 0$</span>) and predict <code>f[n-σ]</code> by <em>extrapolation</em> to (real)  positions <span>$v&lt;n$</span> (using <span>$σ &gt; 0$</span>) or <span>$v&gt;n+k$</span> (using <span>$σ &lt; -k$</span>).  </p><p>NB. The forward offset is defined as <span>$σ ≡ n-v$</span>.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n-k:n]$</span>. The interpolated value <span>$f[n+σ]$</span> is given by the backward-difference expansion</p><p class="math-container">\[f[n+σ] = \sum_{p=0}^k β_p(σ) ∇^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span>. </p><p>Application: This polynom can serve to predict <code>f[n+1]</code> by <em>extrapolation</em> (using <span>$σ=1$</span>)  if <code>f[n-k:n]</code> are known. More generally, it can serve to <em>interpolate</em> to (real) positions  <span>$n-k ≤ v ≤ n$</span> (using <span>$-k ≤ σ ≤ 0$</span>) and predict <code>f[n+σ]</code> by <em>extrapolation</em> to (real)  positions <span>$xv&lt;n$</span> (using <span>$σ &gt; 0$</span>) or <span>$v&gt;n+k$</span> (using <span>$σ &lt; -k$</span>). </p><p>NB. The backward offset is defined as <span>$σ ≡ -(n-v)$</span>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; σ = 1; # offset correponding to extrapolation

julia&gt; α = fdiff_interpolation_expansion_polynom(σ, k, fwd); println(&quot;α = $α&quot;)
α = [1, -1, 1, -1, 1, -1]

julia&gt; Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
Fk = [6, -15, 20, -15, 6, -1]

julia&gt; β = fdiff_interpolation_expansion_polynom(σ, k, bwd); println(&quot;β = $β&quot;)
β = [1, 1, 1, 1, 1, 1]

julia&gt; revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
revBk = [-1, 6, -15, 20, -15, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L234-L299">source</a></section></article><h2 id="Lagrangian-differentiation"><a class="docs-heading-anchor" href="#Lagrangian-differentiation">Lagrangian differentiation</a><a id="Lagrangian-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-differentiation" title="Permalink"></a></h2><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n-σ] = (1+Δ)^{-σ} f[n]\]</p><p>with respect to <span>$-σ$</span>,</p><p class="math-container">\[-\frac{df}{dσ}[n-σ]
=ln(1+Δ)\ (1+Δ)^{-σ}f[n]
=\sum_{q=1}^{k}(-1)^q\tfrac{1}{q}Δ^{q}\sum_{p=0}^{k}(-1)^p\ l_{p}(σ)Δ^{p}f[n]+⋯,\]</p><p>where <span>$l_p(σ) ≡ (σ)_p/p!$</span>, with <span>$(σ)_{p}$</span> being the Pochhammer symbol <code>CamiMath.pochhammer</code>.   Rewriting the r.h.s. as a single expansion in powers of <span>$Δ$</span>, we obtain to order <span>$k$</span></p><p class="math-container">\[-\frac{df}{dσ}[n-σ]=\sum_{p=1}^{k}α_p(σ)Δ^{p}f[n]=F^k(σ) ⋅ f[n:n+k],\]</p><p>where <span>$α_p(σ)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n-σ$</span>. </p><p>In the general case <span>$(σ ≠ 0)$</span>, the coefficients <span>$α_p(σ)$</span> are obtained numerically  by polynomial multiplication using the function <a href="https://walra356.github.io/CamiMath.jl/stable/man/polynomials/#CamiMath.polynom_product-Tuple%7BAny%2C%20Any%7D"><code>CamiMath.polynom_product(p_a, p_b)</code></a>, where</p><p class="math-container">\[\begin{aligned}
p_a &amp;= [0, -1, 1/2, ⋯ (-1)^k\ 1/k] \\
p_b &amp;= [l_0(σ), -l_1(σ), ⋯ (-1)^k l_k(σ)].
\end{aligned}\]</p><p>Special case:</p><p>In the special case <span>$σ = 0$</span>, we have <span>$p_b = [ 1, 0, ⋯, 0]$</span> and the <em>fwd-difference</em>  coefficient vector for <em>lagrangian differentiation</em> at position <span>$n$</span> reduces to</p><p class="math-container">\[α^k = α^k(0) = p_a = [0, -1, 1/2, ⋯ (-1)^k\ 1/k].\]</p><hr/><p>Summary:</p><p>In <code>CamiDiff</code>, the <code>polynom</code> of the <em>forward-differentiation</em> expansion is calculated by</p><p><code>polynom =</code> <a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ α(σ) ≡ [α_0(σ),⋯\ α_k(σ)]$</span>,  with <span>$α_0(σ)≡ 0$</span>.</p><p>Once we have the <em>coefficients</em> (in the form of <code>polynom</code>) we can calculate the <em>weights</em>  (the <em>fwd-differentiation</em> weights vector) in reg-fwd-notation,</p><p><code>weights =</code> <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, fwd, reg)</code></a> <span>$→ F^k(σ) ≡ [F^k_0(σ),⋯\ F^k_k(σ)]$</span>,</p><p>and the <em>derivative</em> at grid position <code>n-σ</code> in fwd-difference notation evaluates to</p><p class="math-container">\[-\frac{df}{dσ}[n-σ]
=\sum_{j=0}^{k}F_j^k(σ)f[n+j]
= F^k(σ) ⋅ f[n:n+k],\]</p><h5 id="Example:"><a class="docs-heading-anchor" href="#Example:">Example:</a><a id="Example:-1"></a><a class="docs-heading-anchor-permalink" href="#Example:" title="Permalink"></a></h5><p>First derivative of the tabulated function <span>$f[n:n+k]$</span> at the position <span>$v = 6.5$</span> (zero-offset)</p><pre><code class="nohighlight hljs">n=5; v=6.5; k=5;

julia&gt; σ = n-v # forward offset at grid position ``v``.
-1.5

julia&gt; α = fdiff_differentiation_expansion_polynom(σ, k, fwd); println(&quot;α = $α&quot;)
α = [0.0, 1.0, 1.0, -0.041666666666666685, 0.0, 0.004687500000000011]

julia&gt; Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
Fk = [0.036979166666666674, -1.1015625, 1.078125, 0.005208333333333426, -0.023437500000000056, 0.004687500000000011]

julia&gt; f = [v^2 for v=1:10]; println(&quot;f = $f&quot;)
f = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

julia&gt; Fk ⋅ f[n:n+k] ≈ 2v
true

julia&gt; f = [v^3 for v=1:10]; println(&quot;f = $f&quot;)
f = [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

julia&gt; Fk ⋅ f[n:n+k] ≈ 3v^2
true</code></pre><hr/><p><strong>backward difference notation</strong> (<code>notation = bwd</code>)</p><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n+σ] = (1 - ∇)^{-σ} f[n]\]</p><p>with respect to <span>$σ$</span>,</p><p class="math-container">\[\frac{df}{dσ}[n+σ]
=-ln(1-∇)\ (1-∇)^{-σ}f[n]
=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(σ)∇^{p}f[n]+⋯,\]</p><p>where <span>$l_p(σ) ≡ (σ)_p/p!$</span>, with <span>$(σ)_{p}$</span> being the Pochhammer symbol <code>CamiMath.pochhammer</code>. Rewriting the r.h.s. as a single expansion in powers of <span>$∇$</span>, we obtain to order <span>$k$</span></p><p class="math-container">\[\frac{df}{dσ}[n+σ]=\sum_{p=1}^{k}β_p(σ)∇^{p}f[n]=\bar{B}^k(σ) ⋅ f[n-k:n],\]</p><p>where <span>$β_p(σ)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n+σ$</span>. </p><p>In the general case <span>$(σ ≠ 0)$</span>, the coefficients <span>$β_p(σ)$</span>  are obtained numerically by polynomial multiplication using the function <a href="https://walra356.github.io/CamiMath.jl/stable/man/polynomials/#CamiMath.polynom_product-Tuple%7BAny%2C%20Any%7D"><code>CamiMath.polynom_product(p_a, p_b)</code></a>, where </p><p class="math-container">\[\begin{aligned}
p_a &amp;= [0, 1, 1/2, ⋯ 1/k]\\
p_b &amp;= [l_0(σ), l_1(σ), ⋯ l_k(σ)].
\end{aligned}\]</p><p>Special case:</p><p>In the special case <span>$σ = 0$</span>, we have <span>$p_b = [ 1, 0, ⋯, 0]$</span> and the <em>bwd-difference</em>  coefficient vector for <em>lagrangian differentiation</em> at position <span>$n$</span> reduces to</p><p class="math-container">\[β^k = β^k(0) = p_a = [0, 1, 1/2, ⋯  1/k].\]</p><hr/><p>Summary:</p><p>In <code>CamiDiff</code>, the <code>polynom</code> of the <em>backward-differentiation</em> expansion is calculated by</p><p><code>polynom =</code> <a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span>,  with <span>$β_0(σ)≡ 0$</span>.</p><p>Once we have the <em>coefficients</em> (in the form of <code>polynom</code>) we can calculate the <em>weights</em>  (the <em>bwd-differentiation</em> weights vector) in rev-bwd-notation,</p><p><span>$\bar{B}^k(σ) =$</span> <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, bwd, rev)</code></a> <span>$→ \bar{B}^k(σ) ≡ [B_k^k(σ),⋯\ B_0^k(σ)]$</span>,</p><p>and the <em>derivative</em> at grid position <code>n+σ</code> in <em>bwd-difference</em> notation evaluates to </p><p class="math-container">\[\frac{df}{dσ}[n+σ]=\bar{B}^k(σ) ⋅ f[n-k:n],\]</p><h5 id="Example:-2"><a class="docs-heading-anchor" href="#Example:-2">Example:</a><a class="docs-heading-anchor-permalink" href="#Example:-2" title="Permalink"></a></h5><p>First derivative of the tabulated function <span>$f[n-k:n]$</span> at the position <span>$v = n$</span> (zero-offset)</p><pre><code class="nohighlight hljs">julia&gt; n=9; v=9; k=5;

julia&gt; σ = -(n-v) # backward offset at grid position ``v``.
0

julia&gt; β = fdiff_differentiation_expansion_polynom(σ, k, bwd); println(&quot;β = $β&quot;)
β = Rational{Int64}[0, 1, 1//2, 1//3, 1//4, 1//5]

julia&gt; revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
revBk = Rational{Int64}[-1//5, 5//4, -10//3, 5, -5, 137//60]

julia&gt; f = [v^2 for v=1:10]; println(&quot;f = $f&quot;)
f = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

julia&gt; revBk ⋅ f[n-k:n] ≈ 2v
true</code></pre><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real" href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiDiff.fdiff_differentiation_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_differentiation_expansion_polynom(σ::T [, k=5 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining <span>$k^{th}$</span>-order <em>lagrangian differentiation</em> of the tabulated analytic function <span>$f[n]$</span> at position  <span>$v=n-σ$</span>.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\frac{df}{dσ}[n+σ]=\sum_{p=0}^kα_p(σ)Δ^{p}f[n]\]</p><p>Offset convention: <span>$σ = n-v$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n:n+k]$</span></p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\frac{df}{dσ}[n+σ]=\sum_{p=0}^kβ_p(σ)∇^{p}f[n]\]</p><p>where <span>$β(σ) ≡ [β_0(σ),\ ⋯,\ β_p(σ)]$</span></p><p>Offset convention: <span>$σ = -(n-v)$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n-k:n]$</span></p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; k = 5; σ = 0; # offset correponding to differentiation

julia&gt; o = fdiff_differentiation_expansion_polynom(0, k, fwd); println(o)
Rational{Int64}[0, 1, -1//2, 1//3, -1//4, 1//5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L365-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}" href="#CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiDiff.create_lagrange_differentiation_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_lagrange_differentiation_matrix(k::Int)</code></pre><p>Lagrange differentiation matrix, <span>$m[i,j]=s_{k-j}^k(i)$</span>, for <span>$k^{th}$</span>-order lagrangian differentiation,</p><p class="math-container">\[\frac{dy}{dx}[i]= \sum_{j=0}^{k}m[i,j]y[j],\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">k = 3
create_lagrange_differentiation_matrix(k)
 4×4 Matrix{Rational{Int64}}:
  -11//6   3//1  -3//2   1//3
   -1//3  -1//2   1//1  -1//6
    1//6  -1//1   1//2   1//3
   -1//3   3//2  -3//1  11//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L410-L428">source</a></section></article><h2 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.trapezoidal_epw-Tuple{Int64}" href="#CamiDiff.trapezoidal_epw-Tuple{Int64}"><code>CamiDiff.trapezoidal_epw</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])</code></pre><p>Endpoint weights vector <span>$a=[a_1,⋯\ a_k]$</span> of trapeziodal rule optimized for functions of polynomial form,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}),\]</p><p>where <span>$k$</span> is <em>odd</em>. The rule is exact for polynonials of degree <span>$d=0,\ 1, ⋯,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]
5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
  (1, 2, [1])
  (3, 24, [9, 28, 23])
  (5, 1440, [475, 1902, 1104, 1586, 1413])
  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])
  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,
                                                     5095890, 7783754, 7200319])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L446-L470">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.trapezoidal_integration-NTuple{4, Any}" href="#CamiDiff.trapezoidal_integration-NTuple{4, Any}"><code>CamiDiff.trapezoidal_integration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trapezoidal_integration(f, x1, x2, weights)</code></pre><p>Integral of the tabulated function <span>$f=[f_0,⋯\ f_n]$</span> over the <code>domain</code> <span>$x1 ≤ x ≤ x2$</span> using the optimized trapezoidal rule with endpoint correction by the weights vector <code>weights</code>,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}).\]</p><p>The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples::</strong></p><pre><code class="nohighlight hljs">p = 3
c = [1 for i=0:p]
pol = ImmutablePolynomial(c,:z)
Ipol = integrate(pol)
n = 10

x1=0.0
x2=5.0
x = collect(range(x1, x2, n))
f = pol.(x .-2.5)

w3 = trapezoidal_epw(3)
trapezoidal_integration(f, x1, x2, w3)
 15.416666666666673

Ipol(2.5)-Ipol(-2.5)
 15.41666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_differences.jl#L511-L543">source</a></section></article><h2 id="Adams-Method"><a class="docs-heading-anchor" href="#Adams-Method">Adams Method</a><a id="Adams-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Method" title="Permalink"></a></h2><h4 id="Adams-Bashford-expansion"><a class="docs-heading-anchor" href="#Adams-Bashford-expansion">Adams-Bashford expansion</a><a id="Adams-Bashford-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashford-expansion" title="Permalink"></a></h4><p>The <em>Adams-Bashford integration step</em> is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{h ∇}{(1-∇)ln(1-∇)}f[n+1]=h (\sum_{p=0}^{\infty}B_p∇^p)f[n+1].\]</p><p>A closed expression for the <em>Adams-Bashford expansion coefficients</em>, <span>$B_k$</span>, is not available. As we already have a finite-difference expansion for the operator <span>$(1-∇)^{-1}$</span>,</p><p class="math-container">\[\frac{1}{1-∇}≡\sum_{p=0}^{\infty}∇^p,\]</p><p>we ask for the expansion of</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+⋯)f[n+1]
= (\sum_{p=0}^{\infty}b_p∇^p)f[n+1].\]</p><p>This is known as the <em>Adams-Moulton expansion</em>. Its expansion coefficients are calculated numerically by the function <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k)</code></a>. The <em>Adams-Bashford expansion</em> is obtained as the polynomial product of the two expansions,</p><p class="math-container">\[(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]
=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]
=\ ( 1 + \frac{1}{2}∇ + \frac{5}{12}∇^2 + ⋯)f[n+1]\]</p><p>where the vector <span>$β = [B_0,⋯\ B_k]$</span> contains the <em>Adams-Bashford expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}B_p∇^pf[n]
=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}A_j^kf[n-j]
= \sum_{j=0}^{k}A_{k-j}^kf[n-k+j],\]</p><p>where the <span>$A_j^k= \sum_{p=j}^{k} B_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Bashford integration weights</em>.</p><p>Function:</p><p><code>β</code> = <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k)</code></a> <span>$→ [B_0,⋯\ B_k]$</span></p><p><code>adams_bashford_weights</code> = <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a>  <span>$→ [A_k^k,⋯\ A_0^k]$</span></p><p><code>adams_bashford_weights</code> = <a href="#CamiDiff.create_adams_bashford_weights-Tuple{Int64}"><code>create_adams_bashford_weights(k)</code></a> <span>$→ [A_k^k,⋯\ A_0^k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}" href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>CamiDiff.fdiff_adams_bashford_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_adams_bashford_expansion_coeff(k::Int [; T=Int [, msg=true]])
fdiff_adams_bashford_expansion_polynom(k::Int [; T=Int [, msg=true]])</code></pre><p><span>$(k+1)$</span>-point Adams-Bashford expansion coefficients <span>$B_k \equiv [B_0^k,⋯\ B_k^k]$</span>.  Note the <em>forward</em> vector ordering, which is the order of use in the summation below,</p><p class="math-container">\[-\frac{∇}{(1-∇)ln(1-∇)}=\sum_{p=0}^{\infty}B_p∇^p=1+\ \frac{1}{2}∇+\ \frac{5}{12}∇^2+\ ⋯.\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; o = fdiff_adams_bashford_expansion_polynom(5); println(o)
Rational{Int64}[1, 1//2, 5//12, 3//8, 251//720, 95//288]

julia&gt; fdiff_adams_bashford_expansion_coeff(0)
1//1

julia&gt; fdiff_adams_bashford_expansion_coeff(5)
95//288

julia&gt; fdiff_adams_bashford_expansion_coeff(20)
Integer-overflow protection: output converted to BigInt
8136836498467582599787//33720021833328230400000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_difference_adams.jl#L194-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.create_adams_bashford_weights-Tuple{Int64}" href="#CamiDiff.create_adams_bashford_weights-Tuple{Int64}"><code>CamiDiff.create_adams_bashford_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_adams_bashford_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Bashford weights vector <span>$b^k \equiv[b_k^k,⋯\ b_0^k]$</span>.  Note the <em>reversed</em> order, which corresponds to the order of use in the summation below,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}b^k[j]f[n+1-k+j],\]</p><p>where <span>$b^k[j] \equiv b_{k-j}^k$</span>. The <span>$b_j^k$</span> are the Adams-Bashford weight coefficients, with <span>$D$</span> the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; [create_adams_bashford_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [-1, 3])
 (2, 12, [5, -16, 23])
 (3, 24, [-9, 37, -59, 55])
 (4, 720, [251, -1274, 2616, -2774, 1901])
 (5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])

julia&gt; k = 5;

julia&gt; w = create_adams_bashford_weights(k; rationalize=true, devisor=true); println(w)
(5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])

julia&gt; w = create_adams_bashford_weights(k; rationalize=true, devisor=false); println(w)
Rational{Int64}[-95//288, 959//480, -3649//720, 4991//720, -2641//480, 4277//1440]

julia&gt; w = create_adams_bashford_weights(k; rationalize=false); println(w)
[-0.3298611111111111, 1.9979166666666666, -5.0680555555555555, 6.9319444444444445, -5.502083333333333, 2.970138888888889]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_difference_adams.jl#L246-L280">source</a></section></article><h3 id="Adams-Moulton-expansion"><a class="docs-heading-anchor" href="#Adams-Moulton-expansion">Adams-Moulton expansion</a><a id="Adams-Moulton-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-expansion" title="Permalink"></a></h3><p>The <em>Adams-Moulton integration</em> step is given by the expansion</p><p class="math-container">\[y[n+1]-y[n]
= -\frac{∇}{ln(1-∇)}f[n+1]
= ( 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯)f[n+1].\]</p><p>For the evaluation of the integration step we limit the summation to <span>$k+1$</span> terms (order <span>$k$</span>),</p><p class="math-container">\[y[n+1]-y[n]= (\sum_{p=0}^{k}b_p∇^p)f[n+1]+⋯.\]</p><p>where the vector <span>$β = [b_0,⋯\ b_k]$</span> contains the <em>Adams-Moulton expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k)</code></a>. Extracting the greatest common denominator, <span>$1/D$</span>, the step becomes</p><p class="math-container">\[y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p′∇^p)f[n+1]+⋯,\]</p><p>where <span>$b_0′,⋯\ b_k′$</span> are integers and <span>$b_p=b_p′/D$</span>. In practice the expansion is restricted to <span>$k&lt;18$</span> (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to <span>$k = 10$</span>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}b_p∇^pf[n]
=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}a_j^kf[n-j]
= \sum_{j=0}^{k}a_{k-j}^kf[n-k+j],\]</p><p>where the <span>$a_j^k= \sum_{p=j}^{k} b_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Moulton integration weights</em>.</p><p>Functions:</p><p><code>β</code> = <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k)</code></a> <span>$→ [b_0,⋯\ b_k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span>.</p><p><code>adams_moulton_weights</code> = <a href="#CamiDiff.create_adams_moulton_weights-Tuple{Int64}"><code>create_adams_moulton_weights(k)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}" href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>CamiDiff.fdiff_adams_moulton_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_adams_moulton_expansion_coeff(k::Int; T=Int, msg=true)
fdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)</code></pre><p>Finite difference expansion coefficient vector <span>$β ≡ [β_0(x),\ ⋯,\ β_k(x)]$</span>. Note the <em>forward</em> vector ordering, which is the order of use in the summation below,</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
= \sum_{p=0}^{\infty}β_p∇^p
= 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯.\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; k = 5;
julia&gt; β = fdiff_adams_moulton_expansion_polynom(k); println(β)
Rational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]

julia&gt; fdiff_adams_moulton_expansion_coeff(k)
-3//160

julia&gt; D = denominator(gcd(β))
1440

julia&gt; convert(Vector{Int},(β .* D)); println(o)
[1440, -720, -120, -60, -38, -27]

julia&gt; k = 20;
julia&gt; fdiff_adams_moulton_expansion_coeff(k)
Integer-overflow protection: output converted to BigInt
-12365722323469980029//4817145976189747200000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_difference_adams.jl#L63-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.create_adams_moulton_weights-Tuple{Int64}" href="#CamiDiff.create_adams_moulton_weights-Tuple{Int64}"><code>CamiDiff.create_adams_moulton_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton weights vector <span>$a^k \equiv[a_k^k,⋯\ a_0^k]$</span>.   Note the <em>reversed</em> vector ordering, which is the order of use in the summation below,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}a^k[j]f[n+1-k+j],\]</p><p>where <span>$a^k[j] \equiv a_{k-j}^k$</span>. The <span>$a_j^k$</span> are the Adams-Moulton weight coefficients and <span>$D$</span> is the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; [create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1, 1])
 (2, 12, [-1, 8, 5])
 (3, 24, [1, -5, 19, 9])
 (4, 720, [-19, 106, -264, 646, 251])
 (5, 1440, [27, -173, 482, -798, 1427, 475])

julia&gt; k = 5;
julia&gt; w = create_adams_moulton_weights(k; rationalize=true, devisor=true); println(w)
(5, 1440, [27, -173, 482, -798, 1427, 475])

julia&gt; w = create_adams_moulton_weights(k; rationalize=true, devisor=false); println(w)
Rational{Int64}[3//160, -173//1440, 241//720, -133//240, 1427//1440, 95//288]

julia&gt; w = create_adams_moulton_weights(k; rationalize=false); println(w)
[0.01875, -0.12013888888888889, 0.3347222222222222, -0.5541666666666667, 0.9909722222222223, 0.3298611111111111]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/5d7ed786dd0e8ac40d93bcdbfa26a52db97e3b39/src/finite_difference_adams.jl#L120-L153">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../grid/">Grid »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Monday 17 February 2025 17:29">Monday 17 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
