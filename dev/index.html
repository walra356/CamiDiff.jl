<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CamiDiff.jl</title><meta name="title" content="Home · CamiDiff.jl"/><meta property="og:title" content="Home · CamiDiff.jl"/><meta property="twitter:title" content="Home · CamiDiff.jl"/><meta name="description" content="Documentation for CamiDiff.jl."/><meta property="og:description" content="Documentation for CamiDiff.jl."/><meta property="twitter:description" content="Documentation for CamiDiff.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CamiDiff.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Install"><span>Install</span></a></li><li><a class="tocitem" href="#Table-of-contents"><span>Table of contents</span></a></li><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Grid"><span>Grid</span></a></li><li><a class="tocitem" href="#Finite-difference-methods"><span>Finite-difference methods</span></a></li><li><a class="tocitem" href="#Adams-Method"><span>Adams Method</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/walra356/CamiDiff.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/walra356/CamiDiff.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CamiDiff.jl"><a class="docs-heading-anchor" href="#CamiDiff.jl">CamiDiff.jl</a><a id="CamiDiff.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CamiDiff.jl" title="Permalink"></a></h1><p>A <a href="http://julialang.org">Julia</a> package for one-dimensional finite-difference analysis</p><hr/><h2 id="Install"><a class="docs-heading-anchor" href="#Install">Install</a><a id="Install-1"></a><a class="docs-heading-anchor-permalink" href="#Install" title="Permalink"></a></h2><p>The package is installed using the Julia package manager</p><pre><code class="nohighlight hljs">julia&gt; using Pkg; Pkg.add(&quot;CamiMath&quot;)

julia&gt; using CamiMath</code></pre><h2 id="Table-of-contents"><a class="docs-heading-anchor" href="#Table-of-contents">Table of contents</a><a id="Table-of-contents-1"></a><a class="docs-heading-anchor-permalink" href="#Table-of-contents" title="Permalink"></a></h2><ul><li><a href="#CamiDiff.jl">CamiDiff.jl</a></li><li class="no-marker"><ul><li><a href="#Install">Install</a></li><li><a href="#Table-of-contents">Table of contents</a></li><li><a href="#Introduction">Introduction</a></li><li><a href="#Grid">Grid</a></li><li><a href="#Finite-difference-methods">Finite-difference methods</a></li><li><a href="#Adams-Method">Adams Method</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p><code>CamiDiff</code> is a package for finite-difference analysis of <em>real analytic functions of a single variable</em>. </p><h3 id="Finite-differences"><a class="docs-heading-anchor" href="#Finite-differences">Finite differences</a><a id="Finite-differences-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-differences" title="Permalink"></a></h3><p>Finite-difference calculus is based on the manipulation of finite differences of analytic functions. To introduce the subject we consider the analytic function <span>$f(x)$</span>. The finite difference of <span>$f(x+h)$</span> and <span>$f(x)$</span> is called the <em>forward difference</em> and is defined as </p><p class="math-container">\[Δ f(x)=f(x+h)-f(x).\]</p><p>Here, <span>$Δ$</span> is called the <em>forward-difference operator</em>. Likewise one defines the <em>backward-difference operator</em> <span>$∇$</span>, </p><p class="math-container">\[∇ f(x)=f(x)-f(x-h).\]</p><p>We first focus on <em>forward differences</em>. The derivative of <span>$f(x)$</span> is given by </p><p class="math-container">\[f^′(x)=\underset{h→0}{\mathrm{lim}}\,\frac{f(x+h)-f(x)}{h}=\underset{Δ x→0}{\mathrm{lim}}\,\frac{Δ f(x)}{Δ x},\]</p><p>where <span>$h ≡ Δx ≥ 0$</span> is the <em>difference interval</em>. Introducing the differential operator, <span>$f^′(x) ≡ Df(x)$</span>, we have </p><p class="math-container">\[D≡\frac{d}{dx}=\underset{Δ x→0}{\mathrm{lim}}\,\frac{Δ}{Δ x}=\underset{h→0}{\mathrm{lim}}\,\frac{Δ}{h}.\]</p><h3 id="Translation-operators"><a class="docs-heading-anchor" href="#Translation-operators">Translation operators</a><a id="Translation-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Translation-operators" title="Permalink"></a></h3><p><strong>Forward difference notation</strong></p><p>With regard to <em>forward differences</em> we rewrite the forward difference definition in the form of a <em>forward translation</em>,</p><p class="math-container">\[f(x+h)=(1+Δ)f(x),\]</p><p>where <span>$T≡(1+Δ)$</span> is the <em>forward translation operator</em>. This operator shifts the function over the infinitesimal interval <span>$h$</span> to larger values of <span>$x$</span>. The translation operator can be expressed in terms of the differential operator as follows by Taylor expansion of <span>$f(x)$</span> about the point <span>$x$</span>, </p><p class="math-container">\[f(x± h)=(1± hD+\tfrac{1}{2}h^2D^2±\tfrac{1}{3!}h^3D^3+⋯)f(x)=e^{± hD}f(x).\]</p><p>Comparing the operator expression for the <em>forward</em> translation with the Taylor expansion we obtain, by formal inversion of the operator <span>$T$</span>, an operator identity for the inverted translation operator <span>$T^{-1}$</span>,    </p><p class="math-container">\[T≡(1+Δ)=e^{hD}\,\,\,⇒\,\,\,T^{-1}=e^{-hD}=(1+Δ)^{-1}.\]</p><p>With this procedure, the explicit dependence on <span>$h$</span> can be replaced by an implicit dependence on <span>$h$</span> through an expansion in powers of <span>$Δ$</span> ,</p><p class="math-container">\[f(x-h)=(1+Δ)^{-1}f(x)=(1-Δ+Δ^{2}-Δ^3+⋯)f(x).\]</p><p>By choosing the proper expansion order, <span>$f(x-h)$</span> can be approximated to any desired level of accuracy.</p><p><strong>Backward difference notation</strong></p><p>Likewise, for <em>backward differences</em>, we rewrite the backward-difference definition in the form </p><p class="math-container">\[f(x-h)=(1-∇)f(x),\]</p><p>where <span>$B≡(1-∇)$</span> is the <em>backward translation operator</em>. Comparing this <em>backward</em> translation with the Taylor expansion we obtain, by formal inversion of the operator <span>$B$</span>, an operator identity for the <em>forward</em> translation operator <span>$T$</span>, </p><p class="math-container">\[B≡(1-∇)=e^{-hD}=T^{-1}\,\,\,⇒\,\,\,T=e^{hD}=(1+∇)^{-1}.\]</p><p>Note how the <em>backward</em> translation operator was identified with the inverse <em>forward</em> translation operator, <span>$B=T^{-1}$</span>. When using backward differences, the explicit dependence on <span>$h$</span> can be replaced by an implicit dependence on <span>$h$</span> through an expansion in powers of <span>$∇$</span>, </p><p class="math-container">\[f(x+h)=(1-∇)^{-1}f(x)=(1+∇+∇^{2}+∇^3+⋯)f(x).\]</p><p>By choosing the proper expansion order, <span>$f(x+h)$</span> can be approximated to any desired level of accuracy. </p><h3 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h3><p>Finite-difference analysis starts by discretization of the function <span>$f(x)$</span> onto a <a href="#Grid"><code>Grid</code></a> of <span>$N$</span> points,  which is based on the map <span>$n ↦ x$</span> and defined by the discrete function</p><p class="math-container">\[x[n] = s_0 * g(t[n]).\]</p><p>Here <span>$g(t)$</span> is called the <a href="#CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>gridfunction</code></a> and <span>$s_0$</span> the <em>scaling factor</em>. The <a href="#CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>gridfunction</code></a>  is a (generally nonlinear) analytic function <em>running through the origin</em>, <span>$g(0) = 0$</span>. Its argument is  the <em>ticks function</em></p><p class="math-container">\[t[n] ≡ (n−u) * h,\]</p><p>which is a <em>linear</em> function, with <span>$u$</span> the <em>index base</em> and <span>$h$</span> the <em>step size</em>. Writing</p><p class="math-container">\[f[n] = f(x[n]),\]</p><p>we recognize in <span>$f[n]$</span> a discrete function representing the function <span>$f(x)$</span> at position <span>$x[n]$</span>, with <span>$n = 1, ⋯ N$</span>. </p><p>Note that <span>$h$</span> determines the <em>coarseness</em> of the <a href="#Grid"><code>Grid</code></a>. The results of a finite-difference calculation  on a coarse grid will be less accurate than those on a fine grid, but the algorithm remains the same because  finite-difference expansions only depend on <span>$h$</span> <em>implicitely</em>. Since <a href="http://julialang.org">Julia</a> uses  unit-based indexing (<span>$u = 1$</span>), the index convention implies <span>$f[1] = f(0)$</span>.  </p><p>NB. The current implementation of <code>CamiDiff</code> was developped for grid functions defined on the domain <span>$[0, ∞)$</span>.  For this case we use the variable <span>$r$</span> rather than <span>$x$</span>, writing <span>$f(r)$</span> rather than <span>$f(x)$</span>, with <span>$r ≥ 0$</span>.</p><h2 id="Grid"><a class="docs-heading-anchor" href="#Grid">Grid</a><a id="Grid-1"></a><a class="docs-heading-anchor-permalink" href="#Grid" title="Permalink"></a></h2><p>The <a href="#Grid"><code>Grid</code></a> object is the backbone for the numerical procedure on a (generally) non-uniform grid. Its principal fields are <code>grid.r</code>, <code>grid.r′</code> and <code>grid.r′′</code> which are discrete functions of <code>N</code> elements representing the grid function and its first two derivatives.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.Grid" href="#CamiDiff.Grid"><code>CamiDiff.Grid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Grid(ID, name, T, N, r, r′, r′′, h, r0, epn, epw, k, p, polynom)</code></pre><p>Type with fields:</p><ul><li><code>.ID</code>:    grid identifer name (<code>::Int</code>)</li><li><code>.name</code>:  grid identifer name (<code>::String</code>)</li><li><code>.T</code>:     gridType (<code>::Type</code>)</li><li><code>.N</code>:     number of grid points (<code>::Int</code>)</li><li><code>.r</code>:   tabulated grid function (<code>::Vector{T}</code>)</li><li><code>.r′</code>:   tabulated first derivative of grid function (<code>::Vector{T}</code>)</li><li><code>.r′′</code>:   tabulated second derivative of grid function (<code>::Vector{T}</code>)</li><li><code>.h</code> :    grid step multiplyer (<code>::T</code>)</li><li><code>.r0</code>:    grid scale factor (<code>::T</code>)</li><li><code>.epn</code>:   number of endpoints used for trapezoidal endpoint correction (must be odd) (<code>::Int</code>)</li><li><code>.epw</code>:   trapezoidal endpoint weights for n=1:epn (<code>::Vector{Vector{T}}</code>)</li><li><code>.k</code>:     finite-difference order (<code>::Int</code>)</li><li><code>.p</code>:     only for quasi-exponential grid; truncation power (<code>::Int</code>)</li><li><code>.polynom</code>: only for polynomial grid: polynom (<code>::Vector{T}</code>)</li></ul><p>The object <code>Grid</code> is best created with the function <a href="#CamiDiff.castGrid-Tuple{Int64, Int64, Type}"><code>castGrid</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L31-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.castGrid-Tuple{Int64, Int64, Type}" href="#CamiDiff.castGrid-Tuple{Int64, Int64, Type}"><code>CamiDiff.castGrid</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">castGrid(ID::Int, N::Int, T::Type; h=1, r0=1,  p=5, polynom=[0,1], epn=5, k=7, msg=false)
castGrid(name::String, N::Int, T::Type; h=1, r0=1, p=5, polynom=[0,1], epn=5, k=7, msg=false)</code></pre><p>Method to create the <a href="#Grid"><code>Grid</code></a> object</p><p><code>ID = 1</code>: exponential, <code>ID = 2</code>: quasi-exponential, <code>ID = 3</code>: linear (uniform) <code>ID = 4</code>: polynomial</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; grid = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);
Grid: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1

julia&gt; grid = castGrid(&quot;exponential&quot;, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);
Grid: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1

julia&gt; grid = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);
Grid: quasi-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1

julia&gt; grid = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);
Grid: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1

julia&gt; grid = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);
Grid: polynomial of degree 2, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001

julia&gt; grid.r[1:4]
4-element Vector{Float64}:
 [2.220446049250313e-16, 1.0000000000000003e-5, 4.000000000000001e-5, 9.000000000000003e-5]

julia&gt; grid.r′[1:4]
4-element Vector{Float64}:
 [0.0, 2.0000000000000005e-5, 4.000000000000001e-5, 6.0000000000000015e-5]
 
julia&gt; grid.r′′[1:4]
4-element Vector{Float64}:
 [2.0000000000000005e-5, 2.0000000000000005e-5, 2.0000000000000005e-5, 2.0000000000000005e-5] </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L219-L258">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real" href="#CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiDiff.gridfunction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gridfunction(ID::Int, n::Int, h::T; p=5, polynom=[0,1], deriv=0) where T &lt;: Real</code></pre><p><code>CamiDiff</code> offers three internal gridfunctions:</p><ul><li><code>ID = 1</code>: exponential grid function,</li></ul><p class="math-container">\[    g(t) = e^t - 1\]</p><ul><li><code>ID = 2</code>: quasi-exponential grid function of degree <code>p</code> (linear grid for <code>p = 1</code>),</li></ul><p class="math-container">\[    g(t) = t + \frac{1}{2}t^2 + ⋯ + \frac{1}{p!}t^p\]</p><ul><li><code>ID = 3</code>: linear grid function,</li></ul><p class="math-container">\[    g(t) = t\]</p><ul><li><code>ID = 4</code>: polynomial grid function of degree <code>p = length(c)-1</code> defined by its <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> vector <span>$c = [c_0, c_1,c_2,⋯\ c_p]$</span>,</li></ul><p class="math-container">\[    g(t) = c_0 + c_1 t + c_2 t^2 + ⋯ + c_p t^p,\]</p><p>with <span>$c_0 ≡ 0$</span> because, <em>by definition</em>, all grid functions run through the origin, <span>$g(0) = 0$</span>. </p><p>The actual grid is given by </p><p class="math-container">\[    x[n] = r_0 * g(t[n]),\]</p><p>where <span>$t[n] = (n-1) * h$</span> is the <em>ticks function</em> for the unit-based indexing of <a href="http://julialang.org">Julia</a>.</p><p>NB. Note that <span>$t[1] = 0$</span> and <span>$x[1] = 0$</span> for all grid functions.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; h = 0.1; r0=1.0; N=4;

julia&gt; r = r0 .* [gridfunction(1, n-1, h) for n=1:N]
[0.0, 0.10517091807564771, 0.22140275816016985, 0.3498588075760032]

julia&gt; r′ = r0 .* [gridfunction(1, n-1, h; deriv=1) for n=1:N]
[0.1, 0.11051709180756478, 0.122140275816017, 0.13498588075760032]

julia&gt; r′′= r0 .* [gridfunction(1, n-1, h; deriv=2) for n=1:N]
[0.010000000000000002, 0.011051709180756479, 0.012214027581601701, 0.013498588075760034]

julia&gt; r = r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1]) for n=1:N]
[0.0, 0.010000000000000002, 0.04000000000000001, 0.09000000000000002]

julia&gt; r′ = r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1], deriv=1) for n=1:N]
[0.0, 0.020000000000000004, 0.04000000000000001, 0.06000000000000001]

julia&gt; r′′= r0 .* [gridfunction(4, n-1, h; polynom=[0,0,1], deriv=2) for n=1:N]
[0.020000000000000004, 0.020000000000000004, 0.020000000000000004, 0.020000000000000004]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L128-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.gridname-Tuple{Int64}" href="#CamiDiff.gridname-Tuple{Int64}"><code>CamiDiff.gridname</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gridname(ID::Int)</code></pre><p>Name corresponding to the <a href="#Grid"><code>Grid</code></a> ID.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; gridname(2)
&quot;quasi-exponential&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L293-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Real" href="#CamiDiff.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Real"><code>CamiDiff.findIndex</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findIndex(rval::T, grid::Grid{T}) where T&lt;:Number</code></pre><p>The largest index <code>i</code> satisfying the condition <code>grid.r[i] &lt; rval</code> on the <a href="#Grid"><code>Grid</code></a>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; h = 0.1; r0 = 1.0;

julia&gt; grid = castGrid(1, 4, Float64; h, r0);

julia&gt; r = grid.r; println(&quot;r[3] = $(r[3])&quot;)
r[3] = 0.22140275816016985

julia&gt; findIndex(0.222, grid)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L319-L335">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.findΔn-Union{Tuple{T}, Tuple{Int64, T, Grid{T}}} where T&lt;:Real" href="#CamiDiff.findΔn-Union{Tuple{T}, Tuple{Int64, T, Grid{T}}} where T&lt;:Real"><code>CamiDiff.findΔn</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">findΔn(n::Int, rval::T, grid::Grid{T}; ϵ = 1e-8, k = 7) where T&lt;:Real</code></pre><p>Fractional grid offset with respect to <a href="#Grid"><code>Grid</code></a> point <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L366-L370">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.grid_interpolation-Union{Tuple{T}, Tuple{Vector{T}, T, Grid{T}}} where T&lt;:Real" href="#CamiDiff.grid_interpolation-Union{Tuple{T}, Tuple{Vector{T}, T, Grid{T}}} where T&lt;:Real"><code>CamiDiff.grid_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_interpolation(f::Vector{T}, rval::T, grid::Grid{T}; k=5) where T&lt;:Real</code></pre><p>Interpolated value for f(rval), with <code>rval</code> not on the <a href="#Grid"><code>Grid</code></a> (<code>rval ∉ grid.r</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real" href="#CamiDiff.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiDiff.grid_differentiation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_differentiation(f::Vector{T}, grid::Grid{T}; k=5) where T&lt;:Real
grid_differentiation(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int; k=5) where T&lt;:Real
grid_differentiation(f::Vector{T}, grid::Grid{T}, itr::UnitRange; k=5) where T&lt;:Real</code></pre><p><span>$k^{th}$</span>-order lagrangian <em>differentiation</em> of the analytic function <span>$f(x)$</span>, tabulated in forward order on a <a href="#Grid"><code>Grid</code></a> of <span>$n$</span> points, <span>$f[1:n]$</span>.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; grid = castGrid(3, 1001, Float64; h=2π/1000.0, r0=1.0, msg=true);
Grid: linear (uniform), Float64, rmax = 6.28947, Ntot = 1001, p = 1, h = 0.00628319, r0 = 1.0

julia&gt; f = [sin(grid.r[i]) for i=1:grid.N]

julia&gt; g = [cos(grid.r[i]) for i=1:grid.N]

julia&gt; grid_differentiation(f, grid) ≈ g
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L450-L469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.grid_integration-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real" href="#CamiDiff.grid_integration-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiDiff.grid_integration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">grid_integration(f::Vector{T}, grid::Grid{T}) where T&lt;:Real
grid_integration(f::Vector{T}, grid::Grid{T}, n1::Int, n2::Int) where T&lt;:Real
grid_integration(f::Vector{T}, grid::Grid{T}, itr::UnitRange) where T&lt;:Real</code></pre><p>Integral of the analytic function <span>$f(r)$</span> tabulated on a generally nonlinear  <a href="#Grid"><code>Grid</code></a> and evaluated with the generalized trapezoidal rule optimized  with endpoint correction by the weightsvector <code>grid.epw</code>,</p><p class="math-container">\[    ∫_{0}^{r_n} f(r) dr = ∫_{0}^{n} f(x) r^{\prime}(x) dx.\]</p><p>Here, the latter integral corresponds to the optimized trapezoidal rule for a uniform grid (see <a href="#CamiDiff.trapezoidal_integration-NTuple{4, Any}"><code>trapezoidal_integration</code></a>). The rule is exact for polynomial functions of degree <span>$d=0,\ 1,⋯\ k-1$</span>, where <span>$k=$</span> <code>grid.epn</code>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; ftest(r) = sqrt(2.0/π) * exp(-r^2/2.0);

julia&gt; grid1 = castGrid(1, 1000, Float64; h = 0.005, r0 = 0.1, msg=true);
Grid created: exponential, Float64, rmax = 14.7413, Ntot = 1000, h = 0.005, r0 = 0.1

julia&gt; grid2 = castGrid(2, 1000, Float64; h = 0.005, r0 = 0.1, p=5, msg=true);
Grid created: quasi-exponential, Float64, rmax = 9.04167, Ntot = 1000, p = 5, h = 0.005, r0 = 0.1

julia&gt; grid3 = castGrid(3, 1000, Float64; h = 0.1, r0 = 0.1, msg=true);
Grid created: linear (uniform), Float64, rmax = 10.0, Ntot = 1000, p = 1, h = 0.1, r0 = 0.1

julia&gt; grid4 = castGrid(4, 1000, Float64; h = 0.1, r0 = 0.001, polynom=[0,0,1], msg=true);
Grid created: polynomial, Float64, rmax = 10.0, Ntot = 1000, polynom = [0.0, 0.0, 1.0], h = 0.1, r0 = 0.001

julia&gt; r1 = grid1.r;
julia&gt; r2 = grid2.r;
julia&gt; r3 = grid3.r;
julia&gt; r4 = grid4.r;
julia&gt; f1 = [ftest(r1[n]) for n=1:grid1.N];
julia&gt; f2 = [ftest(r2[n]) for n=1:grid2.N];
julia&gt; f3 = [ftest(r3[n]) for n=1:grid3.N];
julia&gt; f4 = [ftest(r4[n]) for n=1:grid4.N];
julia&gt; o1 = grid_integration(f1, grid1);
julia&gt; o2 = grid_integration(f2, grid2);
julia&gt; o3 = grid_integration(f3, grid3, 1:900);
julia&gt; o4 = grid_integration(f4, grid4, 1:900);

julia&gt; println(&quot;integral on &quot; * grid1.name * &quot; grid = &quot;, o1)
integral on exponential grid = 1.0

julia&gt; println(&quot;integral on &quot; * grid2.name * &quot; grid = &quot;, o2)
integral on quasi-exponential grid: 1.0

julia&gt; println(&quot;integral on &quot; * grid3.name * &quot; grid = &quot;, o3)
integral on linear (uniform) grid = 1.000000000000003

julia&gt; println(&quot;integral on &quot; * grid3.name * &quot; grid = &quot;, o4)
integral on polynomial grid = 1.0000000000000013</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/grid.jl#L538-L594">source</a></section></article><h2 id="Finite-difference-methods"><a class="docs-heading-anchor" href="#Finite-difference-methods">Finite-difference methods</a><a id="Finite-difference-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-methods" title="Permalink"></a></h2><h3 id="Finite-differences-2"><a class="docs-heading-anchor" href="#Finite-differences-2">Finite differences</a><a class="docs-heading-anchor-permalink" href="#Finite-differences-2" title="Permalink"></a></h3><p>Consider the analytical function <span>$f$</span> tabulated in <em>forward order</em>   (growing index) at <span>$n$</span> positions on a <em>uniform grid</em>.</p><p><strong>Forward difference notation</strong></p><p>In <em>forward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[Δ f[n] = f[n+1]-f[n],\]</p><p>where <span>$Δ$</span> is the forward difference operator. By a formal inversion   procedure we find</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n],\]</p><p>where <span>$Δ^k$</span> is the  <span>$k^{th}$</span>-<em>order forward difference</em> defined as a <em>weighted sum</em> over the function values <span>$f[n:n+k]$</span> (involving <span>$k+1$</span> points),</p><p class="math-container">\[Δ^k f[n] = c_{k}^kf[n] + c_{k-1}^kf[n+1] + ⋯  + f[n+k]
= \sum_{j=0}^{k} c_{k-j}^k f[n+j].\]</p><p>The <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{k-j}^{k}=(-1)^{k-j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation.</p><p><strong>Backward difference notation</strong></p><p>In <em>backward difference</em> notation, the <em>finite difference</em> of two adjacent values on the grid is defined as</p><p class="math-container">\[∇ f[n] = f[n]-f[n-1],\]</p><p>where <span>$∇$</span> is the backward difference operator.  By a formal inversion   procedure we find</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><p>where <span>$∇^k$</span> is the  <span>$k^{th}$</span>-<em>order backward difference</em> defined as a <em>weighted sum</em> over the function values tabulated in backward order, <span>$f[n:-1:n-k]$</span> (involving <span>$k+1$</span> points),</p><p class="math-container">\[∇^k f[n] = f[n] + c_1^kf[n-1] + ⋯ + c_k^kf[n-k]
= \sum_{j=0}^{k} c_j^kf[n-j],\]</p><p>where the <span>$k+1$</span> coefficients</p><p class="math-container">\[c_{j}^{k}=(-1)^{j}\binom{k}{j}\]</p><p>are the <em>summation weights</em> (short: <em>weights</em>) which define the summation. Note the special cases <span>$c_{0}^{k}≡1$</span>, <span>$c_{k}^{k}≡(-1)^{k}$</span> and the symmetry relation</p><p class="math-container">\[c_{k-j}^k=(-1)^k c_j^k.\]</p><p>Coefficients:  </p><p><a href="#CamiDiff.fdiff_weight-Tuple{Int64, Int64}"><code>fdiff_weight(k,j)</code></a> <span>$→ c_j^k=(-1)^j\binom{k}{j}$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_weight-Tuple{Int64, Int64}" href="#CamiDiff.fdiff_weight-Tuple{Int64, Int64}"><code>CamiDiff.fdiff_weight</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_weight(k::Int, j::Int)</code></pre><p>Finite difference weight coefficient,</p><p class="math-container">\[c_{j}^{k}=(-1)^{k+j}\binom{k}{j}.\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">c(k,j) = fdiff_weight(k,j)

[[c(k,j) for j=0:k] for k=0:3] == [[1], [1, -1], [1, -2, 1], [1, -3, 3, -1]]
  true

[[c(k,k-j) for j=0:k] for k=0:3] == [[1], [-1, 1], [1, -2, 1], [-1, 3, -3, 1]]
  true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L31-L49">source</a></section></article><h3 id="Finite-difference-expansions"><a class="docs-heading-anchor" href="#Finite-difference-expansions">Finite difference expansions</a><a id="Finite-difference-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-difference-expansions" title="Permalink"></a></h3><p>Finite-difference calculus builds on the <em>finite-difference expansion</em>.</p><p><strong>Forward difference notation</strong></p><p>In terms of forward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}Δ^{p}f[n]+⋯.\]</p><p>A finite-difference expansion truncated at order <span>$k$</span> is defined by <span>$k+1$</span> <em>finite-difference expansion coefficients</em>, represented by the vector <span>$α = [α_{0},⋯\ α_{k}]$</span>. It takes some bookkeeping to rewrite the expansion as a <em>weighted sum</em> over the <span>$k+1$</span> <em>function values in forward tabulated form</em> <span>$f[n:n+k]$</span>. Substituting the finite difference expression for <span>$Δ^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{p=0}^{k}α_{p}\sum_{j=0}^{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}α_{p}c_{p-j}^{p}f[n+j]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j],\]</p><p>where the weighted summation is defined by the <em>weights</em></p><p class="math-container">\[F_{j}^{k}=\sum_{p=j}^{k}α_{p}c_{p-j}^{p}
=\sum_{p=j}^{k}(-1)^{p+j}\binom{p}{j}α_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$F^k  ≡ [F_0^k,⋯\ F_k^k]$</span>.</p><p class="math-container">\[f[n:n+k] = \left[\begin{array}{c}
f[n]\\
\vdots\\
f[n+k]
\end{array}\right].\]</p><p>Coefficients:</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where <code>polynom</code> is the <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> vector <span>$α ≡ [α_0,⋯\ α_k]$</span>. This <code>polynom</code> has to be supplied by the user to define the expansion under consideration. Some common cases are:</p><p>interpolation expansion: <a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(ξ, k, fwd)</code></a></p><p>differentiation expansion: <a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(ξ, k, fwd)</code></a></p><p>Adams-Bashford expansion: <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k, fwd)</code></a></p><p>Adams-Moulton expansion: <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k, fwd)</code></a></p><p><strong>Backward difference notation</strong></p><p>In terms of backward differences the expansion takes the form</p><p class="math-container">\[\sum_{p=0}^{\infty}β_{p}∇^{p}f[n]=\sum_{p=0}^{k}β_{p}∇^{p}f[n]+⋯.\]</p><p>In this case the <span>$k^{th}$</span>- order <em>finite-difference expansion</em> is defined by the vector <span>$β = [β_{0},⋯\ β_{k}]$</span>. The expansion can written as <em>weighted sum</em> over the <span>$k+1$</span> <em>function values in backward tabulated form</em> <span>$f[n:-1:n-k]$</span>. Substituting the finite difference expression for <span>$∇^k$</span>, we obtain</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{p=0}^{k}β_{p}\sum_{j=0}^{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}\sum_{p=j}^{k}β_{p}c_{j}^{p}f[n-j]
=\sum_{j=0}^{k}B_{j}^{k}f[n-j],\]</p><p>where the <em>weights</em> are given by</p><p class="math-container">\[B_{j}^{k}=\sum_{p=j}^{k}β_{p}c_{j}^{p}
=\sum_{p=j}^{k}(-1)^{j}\binom{p}{j}β_{p},\]</p><p>with <span>$j=0,⋯\ k$</span>. In inner product form the expansion becomes</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^k B_j^k f[n-j]
=\bar{B}^k \cdot f[n-k:n],\]</p><p>where the <em>weights vector</em> <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> contains the weights in backward order.</p><p>In general there is <em>no simple symmetry relation</em> between <span>$B^k$</span> and <span>$F^k$</span>.</p><p>Coefficients:</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where <code>polynom</code> is the <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> vector  <span>$β ≡ [β_0,⋯\ β_k]$</span>. This <code>polynom</code> has to be supplied by the user to define the expansion under consideration. Some common cases are:</p><p>interpolation expansion: <a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(ξ, k, bwd)</code></a></p><p>differentiation expansion: <a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(ξ, k, bwd)</code></a></p><p>Adams-Bashford expansion: <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k, bwd)</code></a></p><p>Adams-Moulton expansion: <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k, bwd)</code></a></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_expansion_weights" href="#CamiDiff.fdiff_expansion_weights"><code>CamiDiff.fdiff_expansion_weights</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_expansion_weights(polynom[, notation=bwd[, ordering=rev]])</code></pre><p>Expansion weights corresponding to the expansion coefficients <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> of a finite difference expansion.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>Weight vector <span>$F^k ≡ [F_k^k,⋯\ F_0^k]$</span> corresponding to the expansion coefficients <span>$α ≡ [α_0^k,⋯\ α_k^k]$</span> of the <span>$k^{th}$</span>-order <em>forward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n]
=\sum_{j=0}^{k}F_{j}^{k}f[n+j]
=F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(α, fwd, reg)</code></a> <span>$→ F^k ≡ [F_0^k,⋯\ F_k^k]$</span>,</p><p>where <span>$α ≡ [α_0,⋯\ α_k]$</span> has to be supplied in combination with <code>fwd</code> to indicate that the weights must be evaluated in forward-difference notation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>Weight vector <span>$\bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span> corresponding to the expansion coefficients <span>$β ≡ [β_0,⋯\ β_k]$</span> of the <span>$k^{th}$</span>-order <em>backward-difference</em> expansion,</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n]
=\sum_{j=0}^{k}B_{j}^kf[n-j]
=\bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytic function <span>$f$</span> tabulated in <em>forward</em> order.</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^{k} ≡ [B_k^k,⋯\ B_0^k]$</span>,</p><p>where <span>$β ≡ [β_0,⋯\ β_k]$</span> has to be supplied in combination with <code>bwd</code> to indicate that the weights must be evaluated in backward-difference notation.</p><p><strong>Example:</strong></p><p>Consider the expansions,</p><p class="math-container">\[f[n-1]=(1+Δ)^{-1}f[n]=(1-Δ+Δ^2-Δ^3+⋯)f[n].\]</p><p class="math-container">\[f[n+1]=(1-∇)^{-1}f[n]=(1+∇+∇^2+∇^3+⋯)f[n],\]</p><pre><code class="nohighlight hljs">α = [1,-1,1,-1,1]
β = [1,1,1,1,1]
Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
  Fk = [5, -10, 10, -5, 1]

Bk = fdiff_expansion_weights(β, bwd, reg); println(&quot;Bk = $(Bk)&quot;)
  Bk = [5, -10, 10, -5, 1]

revFk = fdiff_expansion_weights(α, fwd, rev); println(&quot;revFk = $(revFk)&quot;)
  revFk = [1, -5, 10, -10, 5]

revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
  revBk = [1, -5, 10, -10, 5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L100-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_expansion" href="#CamiDiff.fdiff_expansion"><code>CamiDiff.fdiff_expansion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_expansion(polynom, f[, notation=bwd])</code></pre><p>Finite difference expansion of the analytical function f(x) tabulated in <em>forward order</em> (growing index) at <span>$k+1$</span> positions on a uniform grid. The expansion coefficients are specified by the vector <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a>. By default <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> are assumed to be in backward-difference notation (<code>bwd</code>). For <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> in forward-difference notation the third argument must be <code>fwd</code>.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\sum_{p=0}^{k}α_{p}Δ^{p}f[n] = F^{k} \cdot f[n:n+k],\]</p><p>where <span>$f[n:n+k]$</span> are elements of the analytical function <span>$f$</span> (tabulated in <em>forward</em> order) and <span>$α ≡ [α_0,⋯\ α_k]$</span> is the vector <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a>, which has to be supplied to define the forward-difference expansion. The corresponding weights vector <span>$F^{k}$</span> is internally generated.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\sum_{p=0}^{k}β_{p}∇^{p}f[n] = \bar{B}^k \cdot f[n-k:n].\]</p><p>where <span>$f[n-k:n]$</span> are elements of the analytical function <span>$f$</span> (tabulated in <em>forward</em> order) and <span>$β ≡ [β_0,⋯\ β_k]$</span> is the vector <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a>, which has to be supplied to define the backward-difference expansion. The corresponding weights vector <span>$\bar{B}^k$</span> is internally generated.</p><p><strong>Examples:</strong></p><p>Consider the function <span>$f(x)=x^2$</span> and the expansions,</p><p class="math-container">\[f(x-1)=(1+Δ)^{-1}=(1-Δ+Δ^2-Δ^3+⋯)f(x).\]</p><p class="math-container">\[f(x+1)=(1-∇)^{-1}=(1+∇+∇^2+∇^3+⋯)f(x),\]</p><p>To fourth order <code>(k=4)</code> the forward- and backward-difference coefficient vectors are <code>α=[1,-1,1,-1,1]</code> and <code>β=[1,1,1,1,1]</code>, respectively. We tabulate the function at <span>$k+1$</span> points, <code>f=[1,4,9,16,25]</code>.</p><pre><code class="nohighlight hljs">α = [1,-1,1,-1,1]
Fk = fdiff_expansion_weights(α, fwd, reg); println(&quot;Fk = $(Fk)&quot;)
  Fk = [5, -10, 10, -5, 1]

β = [1,1,1,1,1]
revBk = fdiff_expansion_weights(β, bwd, rev); println(&quot;revBk = $(revBk)&quot;)
  revBk = [1, -5, 10, -10, 5]

f = [1,4,9,16,25]
o = fdiff_expansion(α, f, fwd); println(&quot;f[0] = $(o)&quot;)
  f[0] = 0

fdiff_expansion(α, f, fwd) == Fk ⋅ f == fdiff_interpolation(f, 0)
  true

o = fdiff_expansion(β, f, bwd); println(&quot;f[6] = $(o)&quot;)
  f[6] = 36

fdiff_expansion(β, f, bwd) == revBk ⋅ f == fdiff_interpolation(f, length(f)+1)
  true</code></pre><p>In these cases the results are exact because the function is quadratic and the expansion is third order (based on the polynomial of <span>$k^{th}$</span> degree running through the <span>$k+1$</span> points of the tabulated function). Note the relation with <a href="#CamiDiff.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>fdiff_interpolation(f, v, k=3)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L193-L259">source</a></section></article><h3 id="Lagrange-polynomial-interpolation/extrapolation"><a class="docs-heading-anchor" href="#Lagrange-polynomial-interpolation/extrapolation">Lagrange-polynomial interpolation/extrapolation</a><a id="Lagrange-polynomial-interpolation/extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrange-polynomial-interpolation/extrapolation" title="Permalink"></a></h3><p>The Lagrange polynomial of degree k on a uniform grid is the polynomial running through k+1 subsequent points on the grid. We derive expressions for interpolation/extrapolation in both forward- and backward-difference notation. Beware that Lagrange interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree k.</p><p><strong>Forward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1+Δ)f[n+1],\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 + Δ)^{-1} f[n] ≡ \sum_{p=0}^{\infty}(-1)^p Δ^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 + Δ)^{-2} f[n] ≡ \sum_{p=0}^{\infty}(-1)^p pΔ^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$n-σ$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n-σ] = (1 + Δ)^{-σ} f[n] ≡ \sum_{p=0}^{\infty} α_p(σ) Δ^p f[n],\]</p><p>where</p><p class="math-container">\[α_p(σ) ≡ (-1)^p(σ)_p/p!\]</p><p>is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian lagrangian interpolation over the interval <span>$-k ≤σ ≤0\ \ (n \le n-σ \le n+k)$</span>,</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol <code>CamiMath.pochhammer</code>. For <span>$σ$</span> outside  the interpolation interval the method corresponds to <em>extrapolation</em> along the Lagrange polynomial. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain  </p><p class="math-container">\[f[n-σ] =\sum_{p=0}^{k}α_p(σ)Δ^pf[n]
=\sum_{j=0}^{k}F_j^k(σ)f[n+j]
=F^k(σ) \cdot f[n:n+k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[F_j^k(σ)= \sum_{p=j}^{k} (-1)^k α_p(σ) c_j^p
=\sum_{p=j}^{k} (-1)^j \binom{p}{j}(σ)_p/p!\]</p><p>are the <em>lagrangian interpolation weights</em> corresponding to the point <span>$f[n-σ]$</span>.</p><p>Symmetry relation:</p><p class="math-container">\[\bar{F}^k(-k-σ) = F^k(σ)\]</p><p>Weight functions:</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, fwd, reg)</code></a> <span>$→ F^k(σ) ≡ [F^k_0(σ),⋯\ F^k_k]$</span>,</p><p>where the vector</p><p><code>polynom =</code><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k, fwd)</code></a> <span>$→ α(σ) ≡ [α_0(σ),⋯\ α_k(σ)]$</span>  contains the coefficients of the lagrangian-interpolation expansion.</p><p><strong>Backward difference notation</strong></p><p>Starting from the relation</p><p class="math-container">\[f[n]=(1-∇)f[n+1].\]</p><p>we obtain by formal operator inversion</p><p class="math-container">\[f[n+1] = (1 - ∇)^{-1} f[n] ≡ \sum_{p=0}^{\infty}∇^p f[n],\]</p><p class="math-container">\[f[n+2] = (1 - ∇)^{-2} f[n] ≡ \sum_{p=0}^{\infty}p∇^p f[n],\]</p><p class="math-container">\[\vdots\]</p><p>where <span>$k$</span> is called the order of the expansion and <span>$n$</span> is the reference index. For interpolation position <span>$n-σ$</span> (where σ may be <em>real</em> valued in index units) these expansions can be generalized to the form of <em>lagrangian interpolation</em>,</p><p class="math-container">\[f[n+σ] = (1 - ∇)^{-σ} f[n] ≡ \sum_{p=0}^{\infty} β_p(σ) ∇^p f[n],\]</p><p>where</p><p class="math-container">\[β_p(σ) ≡ (σ)_p/p! = (-1)^p α_p(σ)\]</p><p>is the <span>$p^{th}$</span>-order <em>finite-difference expansion coefficient</em> for lagrangian interpolation over the interval <span>$-k ≤σ ≤0\ \ (n-k \le n+σ \le n)$</span>, with</p><p class="math-container">\[(σ)_{p}=\begin{cases}
1 &amp; p=0\\
σ(σ+1)(σ+2)\cdots(σ+p-1) &amp; p&gt;0
\end{cases}\]</p><p>being the Pochhammer symbol <code>CamiMath.pochhammer</code>. For <span>$σ$</span> outside  the interpolation interval the method corresponds to <em>extrapolation</em> along the Lagrange polynomial. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain</p><p class="math-container">\[f[n+σ] =\sum_{p=0}^{k}β_p(σ)∇^pf[n]
= \sum_{j=0}^{k}B^k_j(σ)f[n-j]
= \bar{B}^k(σ) ⋅ f[n-k:n],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[B^k_j(σ)= \sum_{p=j}^{k} β_p(σ) c_j^p\]</p><p>are the corresponding <em>lagrangian interpolation weights</em>.  </p><p>Symmetry relations:</p><p class="math-container">\[B^k(σ) = F^k(σ) = \bar{B}^k(-k-σ)\]</p><p class="math-container">\[\bar{B}^k(σ) = B^k(-k-σ)\]</p><p>Weight function:</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(polynom, bwd, rev)</code></a> <span>$→ \bar{B}^k(σ) ≡ [B_k^k(σ),⋯\ B_0^k(σ)]$</span>,</p><p>where the vector</p><p><code>polynom =</code><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(σ, k=3, notation=bwd)</code></a> <span>$→ β(σ) ≡ [β_0(σ),⋯\ β_k(σ)]$</span> contains the coefficients of the lagrangian-interpolation expansion.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real" href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiDiff.fdiff_interpolation_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_interpolation_expansion_polynom(ξ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining the <span>$k^{th}$</span>-order (default <em>third</em> order) Lagrange-polynomial interpolation of a tabulated analytic function <span>$f[n]$</span> at offset <span>$ξ$</span> with respect to index position <span>$n$</span>, which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n:n+k]$</span>. The interpolated value <span>$f[n+ξ]$</span> is given by the forward-difference expansion</p><p class="math-container">\[f[n+ξ] = \sum_{p=0}^k α_p(-ξ) Δ^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(ξ, k, fwd)</code></a> <span>$→ α(-ξ) ≡ [α_0(-ξ),⋯\ α_k(-ξ)]$</span>. In this notation the range <span>$0\leq ξ\leq k$</span> corresponds to interpolation and the ranges <span>$ξ&lt;0$</span> and <span>$ξ&gt;k$</span> to extrapolation.</p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p>In this case we consider the tabulated interval <span>$f[n-k:n]$</span>. The interpolated value <span>$f[n+ξ]$</span> is given by the backward-difference expansion</p><p class="math-container">\[f[n+ξ] = \sum_{p=0}^k β_p(ξ) ∇^p f[n] + ⋯,\]</p><p>where the expansion coefficients are given by</p><p><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>fdiff_interpolation_expansion_polynom(ξ, k, bwd)</code></a> <span>$→ β(ξ) ≡ [β_0(ξ),⋯\ β_k(ξ)]$</span>. In this notation the range <span>$-k\leq ξ\leq0$</span> corresponds to interpolation and the ranges <span>$ξ&lt;-k$</span> and <span>$ξ&gt;0$</span> to extrapolation.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">k = 5
ξ = -1
α = fdiff_interpolation_expansion_polynom(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_polynom(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, 1, 0, 0, 0, 0]
  β = [1, 1, 1, 1, 1, 1]

ξ = 0
α = fdiff_interpolation_expansion_polynom(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_polynom(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, 0, 0, 0, 0, 0]
  β = [1, 0, 0, 0, 0, 0]

ξ = 1
α = fdiff_interpolation_expansion_polynom(ξ, k, fwd); println(&quot;α = $α&quot;)
β = fdiff_interpolation_expansion_polynom(ξ, k, bwd); println(&quot;β = $β&quot;)
  α = [1, -1, 1, -1, 1, -1]
  β = [1, -1, 0, 0, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L295-L355">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}" href="#CamiDiff.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiDiff.fdiff_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_interpolation(f::Vector{T}, v::V; k=3) where {T&lt;:Real, V&lt;:Real}</code></pre><p>Finite difference lagrangian interpolation (by default <em>third</em> order) at real position v (in index units) with respect to the elements of the uniformly tabulated analytic function <code>f[1:N]</code>. The interpolation points are situated on a Lagrange polynomial of degree <span>$k$</span> (by default <em>third</em> degree) running through <span>$k+1$</span> subsequenct points of the tabulated function. Outside the tabulated range, the method represents extrapolation on the lagrangian polynomial defined by the first/last <span>$k+1$</span> tabulated points.</p><p>Beware that the interpolation becomes inaccurate if the tabulated function cannot be approximated by a polynomial of degree <span>$k$</span>.</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">f = [1,2,3,4,5,6,7]
[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]
  [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0]

f = [1,4,9,16,25,36,49]
[fdiff_interpolation(f, v; k=3) for v=1:0.5:7]
 [1.0, 2.25, 4.0, 6.25, 9.0, 12.25, 16.0, 20.25, 25.0, 30.25, 36.0, 42.25, 49.0]

 f = [x^3 for x=-4:2]
 f1(v) = fdiff_interpolation(f, v; k=1)
 f2(v) = fdiff_interpolation(f, v; k=2)
 f3(v) = fdiff_interpolation(f, v; k=3)
 [[f1(v),f2(v),f3(v)] for v=1:0.5:9]
   [[-64.0, -64.0, -64.0], [-45.5, -43.25, -42.875], [-27.0, -27.0, -27.0],
   [-17.5, -16.0, -15.625], [-8.0, -8.0, -8.0], [-4.5, -3.75, -3.375],
   [-1.0, -1.0, -1.0], [-0.5, -0.5, -0.125], [0.0, 0.0, 0.0],
   [0.5, -0.25, 0.125], [1.0, 1.0, 1.0], [4.5, 3.75, 3.375], [8.0, 8.0, 8.0],
   [11.5, 13.75, 15.625], [15.0, 21.0, 27.0], [18.5, 29.75, 42.875],
   [22.0, 40.0, 64.0]]</code></pre><p>The result for f3(v) is exact because the function is cubic and the expansion is third order - see Figure below. The tabulated function is given by the black points. The interpolation and extrapolation points are red.</p><p><img src="assets/lagrangian_interpolation.png" alt="Image"/></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L413-L453">source</a></section></article><h3 id="Lagrangian-differentiation"><a class="docs-heading-anchor" href="#Lagrangian-differentiation">Lagrangian differentiation</a><a id="Lagrangian-differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Lagrangian-differentiation" title="Permalink"></a></h3><p>To derive the <em>lagrangian differentiation</em> formulas we formally differentiate</p><p class="math-container">\[f[n+x] = (1 - ∇)^{-x} f[n]\]</p><p>with respect to <span>$x$</span>,</p><p class="math-container">\[\frac{df}{dx}[n+x]
=-ln(1-∇)\ (1-∇)^{-x}f[n]
=\sum_{q=1}^{k}\tfrac{1}{q}∇^{q}\sum_{p=0}^{k}l_{p}(x)∇^{p}f[n]+⋯.\]</p><p>Rewriting the r.h.s. as a single expansion in powers of <span>$∇$</span>, we obtain</p><p class="math-container">\[\frac{df}{dx}[n+x]=\sum_{p=1}^{k}β_p(x)∇^{p}f[n]+⋯,\]</p><p>where <span>$β_p(x)$</span> represents the <em>finite-difference expansion coefficients</em> for <em>lagrangian differentiation</em> at position <span>$n+x$</span>. The coefficients <span>$β_p(x)$</span>  are obtained by polynomial multiplication using the function <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom_product-Tuple%7BAny%2C%20Any%7D"><code>CamiMath.polynom_product(p1,p2)</code></a>,  where <span>$p_1$</span> and <span>$p_2$</span> are <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> vectors.  The resulting coefficients are contained in the following <a href="https://walra356.github.io/CamiMath.jl/stable/#CamiMath.polynom"><code>CamiMath.polynom</code></a> vector of order <span>$k$</span>, </p><p><a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>fdiff_differentiation_expansion_polynom(k,x)</code></a> <span>$→ β(x) ≡ [β_0(x),⋯\ β_p(x)]$</span>, with <span>$β_0(x)≡ 0$</span>.</p><p>Substituting the <em>finite-difference operators</em>, the <em>lagrangian derivative</em> takes the form  </p><p class="math-container">\[\frac{df}{dx}[n+x]
=\sum_{j=0}^{k}B_j^k(x)f[n-j]
=B^k(x) ⋅ f[n:-1:n-k],\]</p><p>where the <span>$k+1$</span> <em>weights</em></p><p class="math-container">\[ B_j^k(x)=\sum_{p=j}^{k}β_p(x)c_{j}^{p}\]</p><p>are the <span>$k^{th}$</span>-order <em>lagrangian-differentiation weights</em></p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, reg)</code></a> <span>$→ B^k(x) ≡ [B^k_0(x),⋯\ B^k_k(x)]$</span>.</p><p>After changing dummy index to reverse the summation the expansion becomes</p><p class="math-container">\[\frac{df}{dx}[n+x]
=\sum_{j=0}^{k}\bar{B}^k_j(x)f[n-k+j]
=\bar{B}^k(x) ⋅ f[n-k:n],\]</p><p>where</p><p><a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ \bar{B}^k(x) ≡ [B^k_k(x),⋯\ B^k_0(x)]$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real" href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>CamiDiff.fdiff_differentiation_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_differentiation_expansion_polynom(ξ::T [, k=3 [, notation=bwd]]) where T&lt;:Real</code></pre><p>Finite-difference expansion coefficient vector defining <span>$k^{th}$</span>-order <em>lagrangian differentiation</em> of the tabulated analytic function <span>$f[n]$</span> at offset <span>$ξ$</span> (with respect to index position <span>$n$</span>), which is positive for increasing index and negative for decreasing index.</p><p><strong>Forward difference notation</strong> (<code>notation = fwd</code>)</p><p class="math-container">\[\frac{df}{dξ}[n+ξ]=\sum_{p=0}^kα_p(ξ)Δ^{p}f[n]\]</p><p>Offset convention: <span>$ξ = -σ$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n:n+k]$</span></p><p><strong>Backward difference notation</strong> (<code>notation = bwd</code>)</p><p class="math-container">\[\frac{df}{dξ}[n+ξ]=\sum_{p=0}^kβ_p(ξ)∇^{p}f[n]\]</p><p>where <span>$β(ξ) ≡ [β_0(ξ),\ ⋯,\ β_p(ξ)]$</span></p><p>Offset convention: <span>$ξ = σ$</span> with respect to index <span>$n$</span> in tabulated interval <span>$f[n-k:n]$</span></p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">k = 2; ξ = 0
o = fdiff_differentiation_expansion_polynom(ξ, k); println(o)
 [0.0, 1.0, -1.5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L523-L555">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}" href="#CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiDiff.create_lagrange_differentiation_matrix</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_lagrange_differentiation_matrix(k::Int)</code></pre><p>Lagrange differentiation matrix, <span>$m[i,j]=s_{k-j}^k(i)$</span>, for <span>$k^{th}$</span>-order lagrangian differentiation,</p><p class="math-container">\[\frac{dy}{dx}[i]= \sum_{j=0}^{k}m[i,j]y[j],\]</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">k = 3
create_lagrange_differentiation_matrix(k)
 4×4 Matrix{Rational{Int64}}:
  -11//6   3//1  -3//2   1//3
   -1//3  -1//2   1//1  -1//6
    1//6  -1//1   1//2   1//3
   -1//3   3//2  -3//1  11//6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L568-L586">source</a></section></article><h3 id="Integration"><a class="docs-heading-anchor" href="#Integration">Integration</a><a id="Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integration" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.trapezoidal_epw-Tuple{Int64}" href="#CamiDiff.trapezoidal_epw-Tuple{Int64}"><code>CamiDiff.trapezoidal_epw</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trapezoidal_epw(k::Int [; rationalize=false [, devisor=false]])</code></pre><p>Endpoint weights vector <span>$a=[a_1,⋯\ a_k]$</span> of trapeziodal rule optimized for functions of polynomial form,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}),\]</p><p>where <span>$k$</span> is <em>odd</em>. The rule is exact for polynonials of degree <span>$d=0,\ 1, ⋯,\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">[trapezoidal_epw(k; rationalize=true, devisor=true) for k=1:2:9]
5-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
  (1, 2, [1])
  (3, 24, [9, 28, 23])
  (5, 1440, [475, 1902, 1104, 1586, 1413])
  (7, 120960, [36799, 176648, 54851, 177984, 89437, 130936, 119585])
  (9, 7257600, [2082753, 11532470, 261166, 16263486, -1020160, 12489922,
                                                     5095890, 7783754, 7200319])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L604-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.trapezoidal_integration-NTuple{4, Any}" href="#CamiDiff.trapezoidal_integration-NTuple{4, Any}"><code>CamiDiff.trapezoidal_integration</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">trapezoidal_integration(f, x1, x2, weights)</code></pre><p>Integral of the tabulated function <span>$f=[f_0,⋯\ f_n]$</span> over the <code>domain</code> <span>$x1 ≤ x ≤ x2$</span> using the optimized trapezoidal rule with endpoint correction by the weights vector <code>weights</code>,</p><p class="math-container">\[    ∫_0^n f(x) dx = a_1 (f_0+f_n) + ⋯ + a_k (f_{k-1}+f_{n-k+1})
                                                         + (f_k+⋯+f_{n-k}).\]</p><p>The rule is exact for polynonials of degree <span>$d=0,\ 1,⋯\ k-1$</span>. For <span>$k=1$</span> the rule reduces to the ordinary trapezoidal rule (weights = [1/2]).</p><p><strong>Examples::</strong></p><pre><code class="nohighlight hljs">p = 3
c = [1 for i=0:p]
pol = ImmutablePolynomial(c,:z)
Ipol = integrate(pol)
n = 10

x1=0.0
x2=5.0
x = collect(range(x1, x2, n))
f = pol.(x .-2.5)

w3 = trapezoidal_epw(3)
trapezoidal_integration(f, x1, x2, w3)
 15.416666666666673

Ipol(2.5)-Ipol(-2.5)
 15.41666666666666</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_differences.jl#L669-L701">source</a></section></article><h2 id="Adams-Method"><a class="docs-heading-anchor" href="#Adams-Method">Adams Method</a><a id="Adams-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Method" title="Permalink"></a></h2><h4 id="Adams-Bashford-expansion"><a class="docs-heading-anchor" href="#Adams-Bashford-expansion">Adams-Bashford expansion</a><a id="Adams-Bashford-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Bashford-expansion" title="Permalink"></a></h4><p>The <em>Adams-Bashford integration step</em> is given by the expansion</p><p class="math-container">\[y[n+1]-y[n] = -\frac{h ∇}{(1-∇)ln(1-∇)}f[n+1]=h (\sum_{p=0}^{\infty}B_p∇^p)f[n+1].\]</p><p>A closed expression for the <em>Adams-Bashford expansion coefficients</em>, <span>$B_k$</span>, is not available. As we already have a finite-difference expansion for the operator <span>$(1-∇)^{-1}$</span>,</p><p class="math-container">\[\frac{1}{1-∇}≡\sum_{p=0}^{\infty}∇^p,\]</p><p>we ask for the expansion of</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
=(1-\frac{1}{2}∇-\frac{1}{24}∇^2-\frac{1}{12}∇^3+⋯)f[n+1]
= (\sum_{p=0}^{\infty}b_p∇^p)f[n+1].\]</p><p>This is known as the <em>Adams-Moulton expansion</em>. Its expansion coefficients are calculated numerically by the function <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k)</code></a>. The <em>Adams-Bashford expansion</em> is obtained as the polynomial product of the two expansions,</p><p class="math-container">\[(\sum_{p=0}^{\infty}B_p∇^p)f[n+1]
=(\sum_{p=0}^{\infty}∇^p)(\sum_{p=0}^{\infty}b_p∇^p)f[n+1]
=\ ( 1 + \frac{1}{2}∇ + \frac{5}{12}∇^2 + ⋯)f[n+1]\]</p><p>where the vector <span>$β = [B_0,⋯\ B_k]$</span> contains the <em>Adams-Bashford expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k)</code></a>. Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}B_p∇^pf[n]
=\sum_{p=0}^{k}B_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}A_j^kf[n-j]
= \sum_{j=0}^{k}A_{k-j}^kf[n-k+j],\]</p><p>where the <span>$A_j^k= \sum_{p=j}^{k} B_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Bashford integration weights</em>.</p><p>Function:</p><p><code>β</code> = <a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_bashford_expansion_polynom(k)</code></a> <span>$→ [B_0,⋯\ B_k]$</span></p><p><code>adams_bashford_weights</code> = <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a>  <span>$→ [A_k^k,⋯\ A_0^k]$</span></p><p><code>adams_bashford_weights</code> = <a href="#CamiDiff.create_adams_bashford_weights-Tuple{Int64}"><code>create_adams_bashford_weights(k)</code></a> <span>$→ [A_k^k,⋯\ A_0^k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}" href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>CamiDiff.fdiff_adams_bashford_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_adams_bashford_expansion_coeff(k::Int [; T=Int [, msg=true]])
fdiff_adams_bashford_expansion_polynom(k::Int [; T=Int [, msg=true]])</code></pre><p><span>$(k+1)$</span>-point Adams-Bashford expansion coefficients <span>$B_k \equiv [B_0^k,⋯\ B_k^k]$</span>.  Note the <em>forward</em> vector ordering, which is the order of use in the summation below,</p><p class="math-container">\[-\frac{∇}{(1-∇)ln(1-∇)}=\sum_{p=0}^{\infty}B_p∇^p=1+\ \frac{1}{2}∇+\ \frac{5}{12}∇^2+\ ⋯.\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; o = fdiff_adams_bashford_expansion_polynom(5); println(o)
Rational{Int64}[1, 1//2, 5//12, 3//8, 251//720, 95//288]

julia&gt; fdiff_adams_bashford_expansion_coeff(0)
1//1

julia&gt; fdiff_adams_bashford_expansion_coeff(5)
95//288

julia&gt; fdiff_adams_bashford_expansion_coeff(20)
Integer-overflow protection: output converted to BigInt
8136836498467582599787//33720021833328230400000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_difference_adams.jl#L194-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.create_adams_bashford_weights-Tuple{Int64}" href="#CamiDiff.create_adams_bashford_weights-Tuple{Int64}"><code>CamiDiff.create_adams_bashford_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_adams_bashford_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Bashford weights vector <span>$b^k \equiv[b_k^k,⋯\ b_0^k]$</span>.  Note the <em>reversed</em> order, which corresponds to the order of use in the summation below,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}b^k[j]f[n+1-k+j],\]</p><p>where <span>$b^k[j] \equiv b_{k-j}^k$</span>. The <span>$b_j^k$</span> are the Adams-Bashford weight coefficients, with <span>$D$</span> the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational, with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; [create_adams_bashford_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [-1, 3])
 (2, 12, [5, -16, 23])
 (3, 24, [-9, 37, -59, 55])
 (4, 720, [251, -1274, 2616, -2774, 1901])
 (5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])

julia&gt; k = 5;

julia&gt; w = create_adams_bashford_weights(k; rationalize=true, devisor=true); println(w)
(5, 1440, [-475, 2877, -7298, 9982, -7923, 4277])

julia&gt; w = create_adams_bashford_weights(k; rationalize=true, devisor=false); println(w)
Rational{Int64}[-95//288, 959//480, -3649//720, 4991//720, -2641//480, 4277//1440]

julia&gt; w = create_adams_bashford_weights(k; rationalize=false); println(w)
[-0.3298611111111111, 1.9979166666666666, -5.0680555555555555, 6.9319444444444445, -5.502083333333333, 2.970138888888889]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_difference_adams.jl#L246-L280">source</a></section></article><h3 id="Adams-Moulton-expansion"><a class="docs-heading-anchor" href="#Adams-Moulton-expansion">Adams-Moulton expansion</a><a id="Adams-Moulton-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Adams-Moulton-expansion" title="Permalink"></a></h3><p>The <em>Adams-Moulton integration</em> step is given by the expansion</p><p class="math-container">\[y[n+1]-y[n]
= -\frac{∇}{ln(1-∇)}f[n+1]
= ( 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯)f[n+1].\]</p><p>For the evaluation of the integration step we limit the summation to <span>$k+1$</span> terms (order <span>$k$</span>),</p><p class="math-container">\[y[n+1]-y[n]= (\sum_{p=0}^{k}b_p∇^p)f[n+1]+⋯.\]</p><p>where the vector <span>$β = [b_0,⋯\ b_k]$</span> contains the <em>Adams-Moulton expansion coefficients</em>, rational numbers generated numerically by the function <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k)</code></a>. Extracting the greatest common denominator, <span>$1/D$</span>, the step becomes</p><p class="math-container">\[y[n+1]-y[n]= \frac{1}{D}(\sum_{p=0}^{k}b_p′∇^p)f[n+1]+⋯,\]</p><p>where <span>$b_0′,⋯\ b_k′$</span> are integers and <span>$b_p=b_p′/D$</span>. In practice the expansion is restricted to <span>$k&lt;18$</span> (as limited by integer overflow). Note that this limit is much higher than values used in calculations (typically up to <span>$k = 10$</span>). Evaluating the finite-difference expansion up to order <span>$k$</span> we obtain (after changing dummy index bring the summation in forward order)</p><p class="math-container">\[\sum_{p=0}^{k}b_p∇^pf[n]
=\sum_{p=0}^{k}b_p\sum_{j=0}^{p} c_j^if[n-j]
= \sum_{j=0}^{k}a_j^kf[n-j]
= \sum_{j=0}^{k}a_{k-j}^kf[n-k+j],\]</p><p>where the <span>$a_j^k= \sum_{p=j}^{k} b_pc_j^p$</span> are the <span>$(k+1)$</span>-point <em>Adams-Moulton integration weights</em>.</p><p>Functions:</p><p><code>β</code> = <a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>fdiff_adams_moulton_expansion_polynom(k)</code></a> <span>$→ [b_0,⋯\ b_k]$</span></p><p><code>adams_moulton_weights</code> = <a href="#CamiDiff.fdiff_expansion_weights"><code>fdiff_expansion_weights(β, bwd, rev)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span>.</p><p><code>adams_moulton_weights</code> = <a href="#CamiDiff.create_adams_moulton_weights-Tuple{Int64}"><code>create_adams_moulton_weights(k)</code></a> <span>$→ [a_k^k,⋯\ a_0^k]$</span></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}" href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>CamiDiff.fdiff_adams_moulton_expansion_polynom</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdiff_adams_moulton_expansion_coeff(k::Int; T=Int, msg=true)
fdiff_adams_moulton_expansion_polynom(k::Int; T=Int, msg=true)</code></pre><p>Finite difference expansion coefficient vector <span>$β ≡ [β_0(x),\ ⋯,\ β_k(x)]$</span>. Note the <em>forward</em> vector ordering, which is the order of use in the summation below,</p><p class="math-container">\[-\frac{∇}{ln(1-∇)}
= \sum_{p=0}^{\infty}β_p∇^p
= 1 - \frac{1}{2}∇ - \frac{1}{12}∇^2 - \frac{1}{24}∇^3 +⋯.\]</p><p><strong>Examples:</strong></p><pre><code class="nohighlight hljs">julia&gt; k = 5;
julia&gt; β = fdiff_adams_moulton_expansion_polynom(k); println(β)
Rational{Int64}[1//1, -1//2, -1//12, -1//24, -19//720, -3//160]

julia&gt; fdiff_adams_moulton_expansion_coeff(k)
-3//160

julia&gt; D = denominator(gcd(β))
1440

julia&gt; convert(Vector{Int},(β .* D)); println(o)
[1440, -720, -120, -60, -38, -27]

julia&gt; k = 20;
julia&gt; fdiff_adams_moulton_expansion_coeff(k)
Integer-overflow protection: output converted to BigInt
-12365722323469980029//4817145976189747200000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_difference_adams.jl#L63-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CamiDiff.create_adams_moulton_weights-Tuple{Int64}" href="#CamiDiff.create_adams_moulton_weights-Tuple{Int64}"><code>CamiDiff.create_adams_moulton_weights</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">create_adams_moulton_weights(k::Int [; rationalize=false [, devisor=false [, T=Int]]])</code></pre><p><span>$k^{th}$</span>-order Adams-Moulton weights vector <span>$a^k \equiv[a_k^k,⋯\ a_0^k]$</span>.   Note the <em>reversed</em> vector ordering, which is the order of use in the summation below,</p><p class="math-container">\[y[n+1] = y[n] + \frac{1}{D}\sum_{j=0}^{k}a^k[j]f[n+1-k+j],\]</p><p>where <span>$a^k[j] \equiv a_{k-j}^k$</span>. The <span>$a_j^k$</span> are the Adams-Moulton weight coefficients and <span>$D$</span> is the corresponding Adams-Moulton divisor. By default the output is in Float64, optionally the output is rational,  with or without specification of the gcd devisor.</p><p><strong>Example:</strong></p><pre><code class="nohighlight hljs">julia&gt; [create_adams_moulton_weights(k; rationalize=true, devisor=true, T=Int) for k=1:5]
8-element Vector{Tuple{Int64, Int64, Vector{Int64}}}:
 (1, 2, [1, 1])
 (2, 12, [-1, 8, 5])
 (3, 24, [1, -5, 19, 9])
 (4, 720, [-19, 106, -264, 646, 251])
 (5, 1440, [27, -173, 482, -798, 1427, 475])

julia&gt; k = 5;
julia&gt; w = create_adams_moulton_weights(k; rationalize=true, devisor=true); println(w)
(5, 1440, [27, -173, 482, -798, 1427, 475])

julia&gt; w = create_adams_moulton_weights(k; rationalize=true, devisor=false); println(w)
Rational{Int64}[3//160, -173//1440, 241//720, -133//240, 1427//1440, 95//288]

julia&gt; w = create_adams_moulton_weights(k; rationalize=false); println(w)
[0.01875, -0.12013888888888889, 0.3347222222222222, -0.5541666666666667, 0.9909722222222223, 0.3298611111111111]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/walra356/CamiDiff.jl/blob/d5563e94eba4850d9cb9a0a69f1c284af630b4dd/src/finite_difference_adams.jl#L120-L153">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CamiDiff.Grid"><code>CamiDiff.Grid</code></a></li><li><a href="#CamiDiff.castGrid-Tuple{Int64, Int64, Type}"><code>CamiDiff.castGrid</code></a></li><li><a href="#CamiDiff.create_adams_bashford_weights-Tuple{Int64}"><code>CamiDiff.create_adams_bashford_weights</code></a></li><li><a href="#CamiDiff.create_adams_moulton_weights-Tuple{Int64}"><code>CamiDiff.create_adams_moulton_weights</code></a></li><li><a href="#CamiDiff.create_lagrange_differentiation_matrix-Tuple{Int64}"><code>CamiDiff.create_lagrange_differentiation_matrix</code></a></li><li><a href="#CamiDiff.fdiff_adams_bashford_expansion_polynom-Tuple{Int64}"><code>CamiDiff.fdiff_adams_bashford_expansion_polynom</code></a></li><li><a href="#CamiDiff.fdiff_adams_moulton_expansion_polynom-Tuple{Int64}"><code>CamiDiff.fdiff_adams_moulton_expansion_polynom</code></a></li><li><a href="#CamiDiff.fdiff_differentiation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}} where T&lt;:Real"><code>CamiDiff.fdiff_differentiation_expansion_polynom</code></a></li><li><a href="#CamiDiff.fdiff_expansion"><code>CamiDiff.fdiff_expansion</code></a></li><li><a href="#CamiDiff.fdiff_expansion_weights"><code>CamiDiff.fdiff_expansion_weights</code></a></li><li><a href="#CamiDiff.fdiff_interpolation-Union{Tuple{V}, Tuple{T}, Tuple{Vector{T}, V}} where {T&lt;:Real, V&lt;:Real}"><code>CamiDiff.fdiff_interpolation</code></a></li><li><a href="#CamiDiff.fdiff_interpolation_expansion_polynom-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Any}} where T&lt;:Real"><code>CamiDiff.fdiff_interpolation_expansion_polynom</code></a></li><li><a href="#CamiDiff.fdiff_weight-Tuple{Int64, Int64}"><code>CamiDiff.fdiff_weight</code></a></li><li><a href="#CamiDiff.findIndex-Union{Tuple{T}, Tuple{T, Grid{T}}} where T&lt;:Real"><code>CamiDiff.findIndex</code></a></li><li><a href="#CamiDiff.findΔn-Union{Tuple{T}, Tuple{Int64, T, Grid{T}}} where T&lt;:Real"><code>CamiDiff.findΔn</code></a></li><li><a href="#CamiDiff.grid_differentiation-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiDiff.grid_differentiation</code></a></li><li><a href="#CamiDiff.grid_integration-Union{Tuple{T}, Tuple{Vector{T}, Grid{T}}} where T&lt;:Real"><code>CamiDiff.grid_integration</code></a></li><li><a href="#CamiDiff.grid_interpolation-Union{Tuple{T}, Tuple{Vector{T}, T, Grid{T}}} where T&lt;:Real"><code>CamiDiff.grid_interpolation</code></a></li><li><a href="#CamiDiff.gridfunction-Union{Tuple{T}, Tuple{Int64, Int64, T}} where T&lt;:Real"><code>CamiDiff.gridfunction</code></a></li><li><a href="#CamiDiff.gridname-Tuple{Int64}"><code>CamiDiff.gridname</code></a></li><li><a href="#CamiDiff.trapezoidal_epw-Tuple{Int64}"><code>CamiDiff.trapezoidal_epw</code></a></li><li><a href="#CamiDiff.trapezoidal_integration-NTuple{4, Any}"><code>CamiDiff.trapezoidal_integration</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Monday 20 January 2025 21:31">Monday 20 January 2025</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
